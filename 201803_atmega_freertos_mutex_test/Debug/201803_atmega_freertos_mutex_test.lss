
201803_atmega_freertos_mutex_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000017e8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  000017e8  0000187c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000063d  00800076  00800076  00001892  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001892  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000018c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000328  00000000  00000000  00001900  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003eaf  00000000  00000000  00001c28  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000121b  00000000  00000000  00005ad7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002487  00000000  00000000  00006cf2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008b4  00000000  00000000  0000917c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000013c1  00000000  00000000  00009a30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003c73  00000000  00000000  0000adf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  0000ea64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1f 03 	jmp	0x63e	; 0x63e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ee       	ldi	r30, 0xE8	; 232
      68:	f7 e1       	ldi	r31, 0x17	; 23
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a6 37       	cpi	r26, 0x76	; 118
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	a6 e7       	ldi	r26, 0x76	; 118
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3b       	cpi	r26, 0xB3	; 179
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 72 00 	call	0xe4	; 0xe4 <main>
      8a:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vLEDInit>:
#include "port_b_led.h"

void vLEDInit(uint8_t bit_port_b)
{
	// Set LED_O as output pin
	DDR_PORT_B |= (1<<bit_port_b);
      92:	97 b3       	in	r25, 0x17	; 23
      94:	21 e0       	ldi	r18, 0x01	; 1
      96:	30 e0       	ldi	r19, 0x00	; 0
      98:	01 c0       	rjmp	.+2      	; 0x9c <vLEDInit+0xa>
      9a:	22 0f       	add	r18, r18
      9c:	8a 95       	dec	r24
      9e:	ea f7       	brpl	.-6      	; 0x9a <vLEDInit+0x8>
      a0:	29 2b       	or	r18, r25
      a2:	27 bb       	out	0x17, r18	; 23
      a4:	08 95       	ret

000000a6 <vLEDToggle>:
}

void vLEDToggle(uint8_t bit_port_b)
{
	//Toggle LED 4
	PORT_B_LED ^= (1<<bit_port_b);
      a6:	98 b3       	in	r25, 0x18	; 24
      a8:	21 e0       	ldi	r18, 0x01	; 1
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	01 c0       	rjmp	.+2      	; 0xb0 <vLEDToggle+0xa>
      ae:	22 0f       	add	r18, r18
      b0:	8a 95       	dec	r24
      b2:	ea f7       	brpl	.-6      	; 0xae <vLEDToggle+0x8>
      b4:	29 27       	eor	r18, r25
      b6:	28 bb       	out	0x18, r18	; 24
      b8:	08 95       	ret

000000ba <vLEDOn>:
}

void vLEDOn(uint8_t bit_port_b)
{
	//On LED 4
	PORT_B_LED |= (1<<bit_port_b);
      ba:	98 b3       	in	r25, 0x18	; 24
      bc:	21 e0       	ldi	r18, 0x01	; 1
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	01 c0       	rjmp	.+2      	; 0xc4 <vLEDOn+0xa>
      c2:	22 0f       	add	r18, r18
      c4:	8a 95       	dec	r24
      c6:	ea f7       	brpl	.-6      	; 0xc2 <vLEDOn+0x8>
      c8:	29 2b       	or	r18, r25
      ca:	28 bb       	out	0x18, r18	; 24
      cc:	08 95       	ret

000000ce <vLEDOff>:
}

void vLEDOff(uint8_t bit_port_b)
{
	//On LED 4
	PORT_B_LED &= ~(1<<bit_port_b);
      ce:	98 b3       	in	r25, 0x18	; 24
      d0:	21 e0       	ldi	r18, 0x01	; 1
      d2:	30 e0       	ldi	r19, 0x00	; 0
      d4:	01 c0       	rjmp	.+2      	; 0xd8 <vLEDOff+0xa>
      d6:	22 0f       	add	r18, r18
      d8:	8a 95       	dec	r24
      da:	ea f7       	brpl	.-6      	; 0xd6 <vLEDOff+0x8>
      dc:	20 95       	com	r18
      de:	29 23       	and	r18, r25
      e0:	28 bb       	out	0x18, r18	; 24
      e2:	08 95       	ret

000000e4 <main>:
uint16_t uint16_delay_time_ms =4000;
SemaphoreHandle_t xMutex;

portSHORT main(void)
{
	xMutex = xSemaphoreCreateMutex();
      e4:	81 e0       	ldi	r24, 0x01	; 1
      e6:	0e 94 3b 06 	call	0xc76	; 0xc76 <xQueueCreateMutex>
      ea:	90 93 b2 06 	sts	0x06B2, r25	; 0x8006b2 <xMutex+0x1>
      ee:	80 93 b1 06 	sts	0x06B1, r24	; 0x8006b1 <xMutex>
	
	xTaskCreate( vLEDFlashTask, ( signed char * ) "LED_6", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
      f2:	e1 2c       	mov	r14, r1
      f4:	f1 2c       	mov	r15, r1
      f6:	00 e0       	ldi	r16, 0x00	; 0
      f8:	20 e0       	ldi	r18, 0x00	; 0
      fa:	30 e0       	ldi	r19, 0x00	; 0
      fc:	45 e5       	ldi	r20, 0x55	; 85
      fe:	50 e0       	ldi	r21, 0x00	; 0
     100:	64 e6       	ldi	r22, 0x64	; 100
     102:	70 e0       	ldi	r23, 0x00	; 0
     104:	83 e9       	ldi	r24, 0x93	; 147
     106:	90 e0       	ldi	r25, 0x00	; 0
     108:	0e 94 76 07 	call	0xeec	; 0xeec <xTaskCreate>
	
	xTaskCreate( vLEDFlashTask_1, ( signed char * ) "LED_7", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
     10c:	20 e0       	ldi	r18, 0x00	; 0
     10e:	30 e0       	ldi	r19, 0x00	; 0
     110:	45 e5       	ldi	r20, 0x55	; 85
     112:	50 e0       	ldi	r21, 0x00	; 0
     114:	6a e6       	ldi	r22, 0x6A	; 106
     116:	70 e0       	ldi	r23, 0x00	; 0
     118:	86 ee       	ldi	r24, 0xE6	; 230
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	0e 94 76 07 	call	0xeec	; 0xeec <xTaskCreate>
	
	//start scheduler
	vTaskStartScheduler();
     120:	0e 94 77 08 	call	0x10ee	; 0x10ee <vTaskStartScheduler>
     124:	ff cf       	rjmp	.-2      	; 0x124 <main+0x40>

00000126 <vLEDFlashTask>:
#include "semphr.h"
#include "queue.h"
#include <stdbool.h>

void vLEDFlashTask( void *pvParameters )
{
     126:	cf 93       	push	r28
     128:	df 93       	push	r29
     12a:	00 d0       	rcall	.+0      	; 0x12c <vLEDFlashTask+0x6>
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62
	static bool bInitialTaskRun =true;
	
	if (bInitialTaskRun ==true)
     130:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <bInitialTaskRun.2025>
     134:	81 11       	cpse	r24, r1
     136:	41 c0       	rjmp	.+130    	; 0x1ba <vLEDFlashTask+0x94>
	portTickType xLastWakeTime;
	
	extern uint16_t uint16_delay_time_ms;
	extern SemaphoreHandle_t xMutex;
	
	xLastWakeTime=xTaskGetTickCount();
     138:	0e 94 a7 08 	call	0x114e	; 0x114e <xTaskGetTickCount>
     13c:	9a 83       	std	Y+2, r25	; 0x02
     13e:	89 83       	std	Y+1, r24	; 0x01
		vLEDToggle(6);
		
		vTaskDelayUntil(&xLastWakeTime,uint16_delay_time_ms);

		if (uint16_delay_time_ms >=3500)
		{ uint16_delay_time_ms =2000; }
     140:	00 ed       	ldi	r16, 0xD0	; 208
     142:	17 e0       	ldi	r17, 0x07	; 7
     144:	12 c0       	rjmp	.+36     	; 0x16a <vLEDFlashTask+0x44>
     146:	10 93 61 00 	sts	0x0061, r17	; 0x800061 <__data_start+0x1>
     14a:	00 93 60 00 	sts	0x0060, r16	; 0x800060 <__data_start>
		else{ uint16_delay_time_ms =uint16_delay_time_ms + 100; }

		xSemaphoreGive(xMutex);
     14e:	20 e0       	ldi	r18, 0x00	; 0
     150:	40 e0       	ldi	r20, 0x00	; 0
     152:	50 e0       	ldi	r21, 0x00	; 0
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	70 e0       	ldi	r23, 0x00	; 0
     158:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <xMutex>
     15c:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <xMutex+0x1>
     160:	0e 94 95 05 	call	0xb2a	; 0xb2a <xQueueGenericSend>
		vLEDOff(4);
     164:	84 e0       	ldi	r24, 0x04	; 4
     166:	0e 94 67 00 	call	0xce	; 0xce <vLEDOff>
	
	xLastWakeTime=xTaskGetTickCount();
	
	for( ;; )
	{
		xSemaphoreTake(xMutex, portMAX_DELAY);
     16a:	20 e0       	ldi	r18, 0x00	; 0
     16c:	4f ef       	ldi	r20, 0xFF	; 255
     16e:	5f ef       	ldi	r21, 0xFF	; 255
     170:	60 e0       	ldi	r22, 0x00	; 0
     172:	70 e0       	ldi	r23, 0x00	; 0
     174:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <xMutex>
     178:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <xMutex+0x1>
     17c:	0e 94 55 06 	call	0xcaa	; 0xcaa <xQueueGenericReceive>
		vLEDOn(4);
     180:	84 e0       	ldi	r24, 0x04	; 4
     182:	0e 94 5d 00 	call	0xba	; 0xba <vLEDOn>
		vLEDToggle(6);
     186:	86 e0       	ldi	r24, 0x06	; 6
     188:	0e 94 53 00 	call	0xa6	; 0xa6 <vLEDToggle>
		
		vTaskDelayUntil(&xLastWakeTime,uint16_delay_time_ms);
     18c:	60 91 60 00 	lds	r22, 0x0060	; 0x800060 <__data_start>
     190:	70 91 61 00 	lds	r23, 0x0061	; 0x800061 <__data_start+0x1>
     194:	ce 01       	movw	r24, r28
     196:	01 96       	adiw	r24, 0x01	; 1
     198:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vTaskDelayUntil>

		if (uint16_delay_time_ms >=3500)
     19c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     1a0:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     1a4:	8c 3a       	cpi	r24, 0xAC	; 172
     1a6:	2d e0       	ldi	r18, 0x0D	; 13
     1a8:	92 07       	cpc	r25, r18
     1aa:	68 f6       	brcc	.-102    	; 0x146 <vLEDFlashTask+0x20>
		{ uint16_delay_time_ms =2000; }
		else{ uint16_delay_time_ms =uint16_delay_time_ms + 100; }
     1ac:	8c 59       	subi	r24, 0x9C	; 156
     1ae:	9f 4f       	sbci	r25, 0xFF	; 255
     1b0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     1b4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     1b8:	ca cf       	rjmp	.-108    	; 0x14e <vLEDFlashTask+0x28>
{
	static bool bInitialTaskRun =true;
	
	if (bInitialTaskRun ==true)
	{
		vLEDInit(4);
     1ba:	84 e0       	ldi	r24, 0x04	; 4
     1bc:	0e 94 49 00 	call	0x92	; 0x92 <vLEDInit>
		vLEDInit(6);
     1c0:	86 e0       	ldi	r24, 0x06	; 6
     1c2:	0e 94 49 00 	call	0x92	; 0x92 <vLEDInit>
		
		bInitialTaskRun =false;
     1c6:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <bInitialTaskRun.2025>
     1ca:	b6 cf       	rjmp	.-148    	; 0x138 <vLEDFlashTask+0x12>

000001cc <vLEDFlashTask_1>:
#include "semphr.h"
#include "queue.h"
#include <stdbool.h>

void vLEDFlashTask_1( void *pvParameters )
{
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	00 d0       	rcall	.+0      	; 0x1d2 <vLEDFlashTask_1+0x6>
     1d2:	cd b7       	in	r28, 0x3d	; 61
     1d4:	de b7       	in	r29, 0x3e	; 62
	static bool bInitialTaskRun =true;
	
	if (bInitialTaskRun ==true)
     1d6:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <bInitialTaskRun.2025>
     1da:	81 11       	cpse	r24, r1
     1dc:	41 c0       	rjmp	.+130    	; 0x260 <vLEDFlashTask_1+0x94>
	portTickType xLastWakeTime;
	
	extern uint16_t uint16_delay_time_ms;
	extern SemaphoreHandle_t xMutex;
	
	xLastWakeTime=xTaskGetTickCount();
     1de:	0e 94 a7 08 	call	0x114e	; 0x114e <xTaskGetTickCount>
     1e2:	9a 83       	std	Y+2, r25	; 0x02
     1e4:	89 83       	std	Y+1, r24	; 0x01
		vLEDToggle(7);
		
		vTaskDelayUntil(&xLastWakeTime,uint16_delay_time_ms);
		
		if (uint16_delay_time_ms <=500)
		{ uint16_delay_time_ms =2000; } 
     1e6:	00 ed       	ldi	r16, 0xD0	; 208
     1e8:	17 e0       	ldi	r17, 0x07	; 7
     1ea:	12 c0       	rjmp	.+36     	; 0x210 <vLEDFlashTask_1+0x44>
     1ec:	10 93 61 00 	sts	0x0061, r17	; 0x800061 <__data_start+0x1>
     1f0:	00 93 60 00 	sts	0x0060, r16	; 0x800060 <__data_start>
		else{ uint16_delay_time_ms =uint16_delay_time_ms - 100; }

		xSemaphoreGive(xMutex);
     1f4:	20 e0       	ldi	r18, 0x00	; 0
     1f6:	40 e0       	ldi	r20, 0x00	; 0
     1f8:	50 e0       	ldi	r21, 0x00	; 0
     1fa:	60 e0       	ldi	r22, 0x00	; 0
     1fc:	70 e0       	ldi	r23, 0x00	; 0
     1fe:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <xMutex>
     202:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <xMutex+0x1>
     206:	0e 94 95 05 	call	0xb2a	; 0xb2a <xQueueGenericSend>
		vLEDOff(5);
     20a:	85 e0       	ldi	r24, 0x05	; 5
     20c:	0e 94 67 00 	call	0xce	; 0xce <vLEDOff>
	
	xLastWakeTime=xTaskGetTickCount();
	
	for( ;; )
	{
		xSemaphoreTake(xMutex, portMAX_DELAY);
     210:	20 e0       	ldi	r18, 0x00	; 0
     212:	4f ef       	ldi	r20, 0xFF	; 255
     214:	5f ef       	ldi	r21, 0xFF	; 255
     216:	60 e0       	ldi	r22, 0x00	; 0
     218:	70 e0       	ldi	r23, 0x00	; 0
     21a:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <xMutex>
     21e:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <xMutex+0x1>
     222:	0e 94 55 06 	call	0xcaa	; 0xcaa <xQueueGenericReceive>
		vLEDOn(5);
     226:	85 e0       	ldi	r24, 0x05	; 5
     228:	0e 94 5d 00 	call	0xba	; 0xba <vLEDOn>
		vLEDToggle(7);
     22c:	87 e0       	ldi	r24, 0x07	; 7
     22e:	0e 94 53 00 	call	0xa6	; 0xa6 <vLEDToggle>
		
		vTaskDelayUntil(&xLastWakeTime,uint16_delay_time_ms);
     232:	60 91 60 00 	lds	r22, 0x0060	; 0x800060 <__data_start>
     236:	70 91 61 00 	lds	r23, 0x0061	; 0x800061 <__data_start+0x1>
     23a:	ce 01       	movw	r24, r28
     23c:	01 96       	adiw	r24, 0x01	; 1
     23e:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vTaskDelayUntil>
		
		if (uint16_delay_time_ms <=500)
     242:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     246:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     24a:	85 3f       	cpi	r24, 0xF5	; 245
     24c:	21 e0       	ldi	r18, 0x01	; 1
     24e:	92 07       	cpc	r25, r18
     250:	68 f2       	brcs	.-102    	; 0x1ec <vLEDFlashTask_1+0x20>
		{ uint16_delay_time_ms =2000; } 
		else{ uint16_delay_time_ms =uint16_delay_time_ms - 100; }
     252:	84 56       	subi	r24, 0x64	; 100
     254:	91 09       	sbc	r25, r1
     256:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     25a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     25e:	ca cf       	rjmp	.-108    	; 0x1f4 <vLEDFlashTask_1+0x28>
{
	static bool bInitialTaskRun =true;
	
	if (bInitialTaskRun ==true)
	{
		vLEDInit(5);
     260:	85 e0       	ldi	r24, 0x05	; 5
     262:	0e 94 49 00 	call	0x92	; 0x92 <vLEDInit>
		vLEDInit(7);
     266:	87 e0       	ldi	r24, 0x07	; 7
     268:	0e 94 49 00 	call	0x92	; 0x92 <vLEDInit>
		
		bInitialTaskRun =false;
     26c:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <bInitialTaskRun.2025>
     270:	b6 cf       	rjmp	.-148    	; 0x1de <vLEDFlashTask_1+0x12>

00000272 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     272:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     274:	03 96       	adiw	r24, 0x03	; 3
     276:	92 83       	std	Z+2, r25	; 0x02
     278:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     27a:	2f ef       	ldi	r18, 0xFF	; 255
     27c:	3f ef       	ldi	r19, 0xFF	; 255
     27e:	34 83       	std	Z+4, r19	; 0x04
     280:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     282:	96 83       	std	Z+6, r25	; 0x06
     284:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     286:	90 87       	std	Z+8, r25	; 0x08
     288:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     28a:	10 82       	st	Z, r1
     28c:	08 95       	ret

0000028e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     28e:	fc 01       	movw	r30, r24
     290:	11 86       	std	Z+9, r1	; 0x09
     292:	10 86       	std	Z+8, r1	; 0x08
     294:	08 95       	ret

00000296 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     296:	cf 93       	push	r28
     298:	df 93       	push	r29
     29a:	9c 01       	movw	r18, r24
     29c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     29e:	dc 01       	movw	r26, r24
     2a0:	11 96       	adiw	r26, 0x01	; 1
     2a2:	cd 91       	ld	r28, X+
     2a4:	dc 91       	ld	r29, X
     2a6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     2a8:	d3 83       	std	Z+3, r29	; 0x03
     2aa:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2ac:	8c 81       	ldd	r24, Y+4	; 0x04
     2ae:	9d 81       	ldd	r25, Y+5	; 0x05
     2b0:	95 83       	std	Z+5, r25	; 0x05
     2b2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     2b4:	8c 81       	ldd	r24, Y+4	; 0x04
     2b6:	9d 81       	ldd	r25, Y+5	; 0x05
     2b8:	dc 01       	movw	r26, r24
     2ba:	13 96       	adiw	r26, 0x03	; 3
     2bc:	7c 93       	st	X, r23
     2be:	6e 93       	st	-X, r22
     2c0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     2c2:	7d 83       	std	Y+5, r23	; 0x05
     2c4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2c6:	31 87       	std	Z+9, r19	; 0x09
     2c8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     2ca:	f9 01       	movw	r30, r18
     2cc:	80 81       	ld	r24, Z
     2ce:	8f 5f       	subi	r24, 0xFF	; 255
     2d0:	80 83       	st	Z, r24
}
     2d2:	df 91       	pop	r29
     2d4:	cf 91       	pop	r28
     2d6:	08 95       	ret

000002d8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2d8:	cf 93       	push	r28
     2da:	df 93       	push	r29
     2dc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2de:	48 81       	ld	r20, Y
     2e0:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2e2:	4f 3f       	cpi	r20, 0xFF	; 255
     2e4:	2f ef       	ldi	r18, 0xFF	; 255
     2e6:	52 07       	cpc	r21, r18
     2e8:	01 f1       	breq	.+64     	; 0x32a <vListInsert+0x52>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ea:	dc 01       	movw	r26, r24
     2ec:	13 96       	adiw	r26, 0x03	; 3
     2ee:	01 c0       	rjmp	.+2      	; 0x2f2 <vListInsert+0x1a>
     2f0:	df 01       	movw	r26, r30
     2f2:	12 96       	adiw	r26, 0x02	; 2
     2f4:	ed 91       	ld	r30, X+
     2f6:	fc 91       	ld	r31, X
     2f8:	13 97       	sbiw	r26, 0x03	; 3
     2fa:	20 81       	ld	r18, Z
     2fc:	31 81       	ldd	r19, Z+1	; 0x01
     2fe:	42 17       	cp	r20, r18
     300:	53 07       	cpc	r21, r19
     302:	b0 f7       	brcc	.-20     	; 0x2f0 <vListInsert+0x18>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     304:	fb 83       	std	Y+3, r31	; 0x03
     306:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     308:	d5 83       	std	Z+5, r29	; 0x05
     30a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     30c:	bd 83       	std	Y+5, r27	; 0x05
     30e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     310:	13 96       	adiw	r26, 0x03	; 3
     312:	dc 93       	st	X, r29
     314:	ce 93       	st	-X, r28
     316:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     318:	99 87       	std	Y+9, r25	; 0x09
     31a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     31c:	fc 01       	movw	r30, r24
     31e:	20 81       	ld	r18, Z
     320:	2f 5f       	subi	r18, 0xFF	; 255
     322:	20 83       	st	Z, r18
}
     324:	df 91       	pop	r29
     326:	cf 91       	pop	r28
     328:	08 95       	ret
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     32a:	fc 01       	movw	r30, r24
     32c:	a7 81       	ldd	r26, Z+7	; 0x07
     32e:	b0 85       	ldd	r27, Z+8	; 0x08
     330:	12 96       	adiw	r26, 0x02	; 2
     332:	ed 91       	ld	r30, X+
     334:	fc 91       	ld	r31, X
     336:	13 97       	sbiw	r26, 0x03	; 3
     338:	e5 cf       	rjmp	.-54     	; 0x304 <vListInsert+0x2c>

0000033a <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     33a:	cf 93       	push	r28
     33c:	df 93       	push	r29
     33e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     340:	a0 85       	ldd	r26, Z+8	; 0x08
     342:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     344:	22 81       	ldd	r18, Z+2	; 0x02
     346:	33 81       	ldd	r19, Z+3	; 0x03
     348:	84 81       	ldd	r24, Z+4	; 0x04
     34a:	95 81       	ldd	r25, Z+5	; 0x05
     34c:	e9 01       	movw	r28, r18
     34e:	9d 83       	std	Y+5, r25	; 0x05
     350:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     352:	84 81       	ldd	r24, Z+4	; 0x04
     354:	95 81       	ldd	r25, Z+5	; 0x05
     356:	ec 01       	movw	r28, r24
     358:	3b 83       	std	Y+3, r19	; 0x03
     35a:	2a 83       	std	Y+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     35c:	11 96       	adiw	r26, 0x01	; 1
     35e:	2d 91       	ld	r18, X+
     360:	3c 91       	ld	r19, X
     362:	12 97       	sbiw	r26, 0x02	; 2
     364:	e2 17       	cp	r30, r18
     366:	f3 07       	cpc	r31, r19
     368:	41 f0       	breq	.+16     	; 0x37a <uxListRemove+0x40>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     36a:	11 86       	std	Z+9, r1	; 0x09
     36c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     36e:	8c 91       	ld	r24, X
     370:	81 50       	subi	r24, 0x01	; 1
     372:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     37a:	12 96       	adiw	r26, 0x02	; 2
     37c:	9c 93       	st	X, r25
     37e:	8e 93       	st	-X, r24
     380:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     382:	11 86       	std	Z+9, r1	; 0x09
     384:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     386:	8c 91       	ld	r24, X
     388:	81 50       	subi	r24, 0x01	; 1
     38a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     38c:	df 91       	pop	r29
     38e:	cf 91       	pop	r28
     390:	08 95       	ret

00000392 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     392:	31 e1       	ldi	r19, 0x11	; 17
     394:	fc 01       	movw	r30, r24
     396:	30 83       	st	Z, r19
     398:	31 97       	sbiw	r30, 0x01	; 1
     39a:	22 e2       	ldi	r18, 0x22	; 34
     39c:	20 83       	st	Z, r18
     39e:	31 97       	sbiw	r30, 0x01	; 1
     3a0:	a3 e3       	ldi	r26, 0x33	; 51
     3a2:	a0 83       	st	Z, r26
     3a4:	31 97       	sbiw	r30, 0x01	; 1
     3a6:	60 83       	st	Z, r22
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	70 83       	st	Z, r23
     3ac:	31 97       	sbiw	r30, 0x01	; 1
     3ae:	10 82       	st	Z, r1
     3b0:	31 97       	sbiw	r30, 0x01	; 1
     3b2:	60 e8       	ldi	r22, 0x80	; 128
     3b4:	60 83       	st	Z, r22
     3b6:	31 97       	sbiw	r30, 0x01	; 1
     3b8:	10 82       	st	Z, r1
     3ba:	31 97       	sbiw	r30, 0x01	; 1
     3bc:	62 e0       	ldi	r22, 0x02	; 2
     3be:	60 83       	st	Z, r22
     3c0:	31 97       	sbiw	r30, 0x01	; 1
     3c2:	63 e0       	ldi	r22, 0x03	; 3
     3c4:	60 83       	st	Z, r22
     3c6:	31 97       	sbiw	r30, 0x01	; 1
     3c8:	64 e0       	ldi	r22, 0x04	; 4
     3ca:	60 83       	st	Z, r22
     3cc:	31 97       	sbiw	r30, 0x01	; 1
     3ce:	65 e0       	ldi	r22, 0x05	; 5
     3d0:	60 83       	st	Z, r22
     3d2:	31 97       	sbiw	r30, 0x01	; 1
     3d4:	66 e0       	ldi	r22, 0x06	; 6
     3d6:	60 83       	st	Z, r22
     3d8:	31 97       	sbiw	r30, 0x01	; 1
     3da:	67 e0       	ldi	r22, 0x07	; 7
     3dc:	60 83       	st	Z, r22
     3de:	31 97       	sbiw	r30, 0x01	; 1
     3e0:	68 e0       	ldi	r22, 0x08	; 8
     3e2:	60 83       	st	Z, r22
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	69 e0       	ldi	r22, 0x09	; 9
     3e8:	60 83       	st	Z, r22
     3ea:	31 97       	sbiw	r30, 0x01	; 1
     3ec:	60 e1       	ldi	r22, 0x10	; 16
     3ee:	60 83       	st	Z, r22
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	30 83       	st	Z, r19
     3f4:	31 97       	sbiw	r30, 0x01	; 1
     3f6:	32 e1       	ldi	r19, 0x12	; 18
     3f8:	30 83       	st	Z, r19
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	33 e1       	ldi	r19, 0x13	; 19
     3fe:	30 83       	st	Z, r19
     400:	31 97       	sbiw	r30, 0x01	; 1
     402:	34 e1       	ldi	r19, 0x14	; 20
     404:	30 83       	st	Z, r19
     406:	31 97       	sbiw	r30, 0x01	; 1
     408:	35 e1       	ldi	r19, 0x15	; 21
     40a:	30 83       	st	Z, r19
     40c:	31 97       	sbiw	r30, 0x01	; 1
     40e:	36 e1       	ldi	r19, 0x16	; 22
     410:	30 83       	st	Z, r19
     412:	31 97       	sbiw	r30, 0x01	; 1
     414:	37 e1       	ldi	r19, 0x17	; 23
     416:	30 83       	st	Z, r19
     418:	31 97       	sbiw	r30, 0x01	; 1
     41a:	38 e1       	ldi	r19, 0x18	; 24
     41c:	30 83       	st	Z, r19
     41e:	31 97       	sbiw	r30, 0x01	; 1
     420:	39 e1       	ldi	r19, 0x19	; 25
     422:	30 83       	st	Z, r19
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	30 e2       	ldi	r19, 0x20	; 32
     428:	30 83       	st	Z, r19
     42a:	31 97       	sbiw	r30, 0x01	; 1
     42c:	31 e2       	ldi	r19, 0x21	; 33
     42e:	30 83       	st	Z, r19
     430:	31 97       	sbiw	r30, 0x01	; 1
     432:	20 83       	st	Z, r18
     434:	31 97       	sbiw	r30, 0x01	; 1
     436:	23 e2       	ldi	r18, 0x23	; 35
     438:	20 83       	st	Z, r18
     43a:	31 97       	sbiw	r30, 0x01	; 1
     43c:	40 83       	st	Z, r20
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	50 83       	st	Z, r21
     442:	31 97       	sbiw	r30, 0x01	; 1
     444:	26 e2       	ldi	r18, 0x26	; 38
     446:	20 83       	st	Z, r18
     448:	31 97       	sbiw	r30, 0x01	; 1
     44a:	27 e2       	ldi	r18, 0x27	; 39
     44c:	20 83       	st	Z, r18
     44e:	31 97       	sbiw	r30, 0x01	; 1
     450:	28 e2       	ldi	r18, 0x28	; 40
     452:	20 83       	st	Z, r18
     454:	31 97       	sbiw	r30, 0x01	; 1
     456:	29 e2       	ldi	r18, 0x29	; 41
     458:	20 83       	st	Z, r18
     45a:	31 97       	sbiw	r30, 0x01	; 1
     45c:	20 e3       	ldi	r18, 0x30	; 48
     45e:	20 83       	st	Z, r18
     460:	31 97       	sbiw	r30, 0x01	; 1
     462:	21 e3       	ldi	r18, 0x31	; 49
     464:	20 83       	st	Z, r18
     466:	86 97       	sbiw	r24, 0x26	; 38
     468:	08 95       	ret

0000046a <xPortStartScheduler>:
     46a:	1b bc       	out	0x2b, r1	; 43
     46c:	8e e0       	ldi	r24, 0x0E	; 14
     46e:	8a bd       	out	0x2a, r24	; 42
     470:	8b e0       	ldi	r24, 0x0B	; 11
     472:	8e bd       	out	0x2e, r24	; 46
     474:	89 b7       	in	r24, 0x39	; 57
     476:	80 61       	ori	r24, 0x10	; 16
     478:	89 bf       	out	0x39, r24	; 57
     47a:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
     47e:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     482:	cd 91       	ld	r28, X+
     484:	cd bf       	out	0x3d, r28	; 61
     486:	dd 91       	ld	r29, X+
     488:	de bf       	out	0x3e, r29	; 62
     48a:	ff 91       	pop	r31
     48c:	ef 91       	pop	r30
     48e:	df 91       	pop	r29
     490:	cf 91       	pop	r28
     492:	bf 91       	pop	r27
     494:	af 91       	pop	r26
     496:	9f 91       	pop	r25
     498:	8f 91       	pop	r24
     49a:	7f 91       	pop	r23
     49c:	6f 91       	pop	r22
     49e:	5f 91       	pop	r21
     4a0:	4f 91       	pop	r20
     4a2:	3f 91       	pop	r19
     4a4:	2f 91       	pop	r18
     4a6:	1f 91       	pop	r17
     4a8:	0f 91       	pop	r16
     4aa:	ff 90       	pop	r15
     4ac:	ef 90       	pop	r14
     4ae:	df 90       	pop	r13
     4b0:	cf 90       	pop	r12
     4b2:	bf 90       	pop	r11
     4b4:	af 90       	pop	r10
     4b6:	9f 90       	pop	r9
     4b8:	8f 90       	pop	r8
     4ba:	7f 90       	pop	r7
     4bc:	6f 90       	pop	r6
     4be:	5f 90       	pop	r5
     4c0:	4f 90       	pop	r4
     4c2:	3f 90       	pop	r3
     4c4:	2f 90       	pop	r2
     4c6:	1f 90       	pop	r1
     4c8:	0f 90       	pop	r0
     4ca:	0f be       	out	0x3f, r0	; 63
     4cc:	0f 90       	pop	r0
     4ce:	08 95       	ret
     4d0:	81 e0       	ldi	r24, 0x01	; 1
     4d2:	08 95       	ret

000004d4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4d4:	0f 92       	push	r0
     4d6:	0f b6       	in	r0, 0x3f	; 63
     4d8:	f8 94       	cli
     4da:	0f 92       	push	r0
     4dc:	1f 92       	push	r1
     4de:	11 24       	eor	r1, r1
     4e0:	2f 92       	push	r2
     4e2:	3f 92       	push	r3
     4e4:	4f 92       	push	r4
     4e6:	5f 92       	push	r5
     4e8:	6f 92       	push	r6
     4ea:	7f 92       	push	r7
     4ec:	8f 92       	push	r8
     4ee:	9f 92       	push	r9
     4f0:	af 92       	push	r10
     4f2:	bf 92       	push	r11
     4f4:	cf 92       	push	r12
     4f6:	df 92       	push	r13
     4f8:	ef 92       	push	r14
     4fa:	ff 92       	push	r15
     4fc:	0f 93       	push	r16
     4fe:	1f 93       	push	r17
     500:	2f 93       	push	r18
     502:	3f 93       	push	r19
     504:	4f 93       	push	r20
     506:	5f 93       	push	r21
     508:	6f 93       	push	r22
     50a:	7f 93       	push	r23
     50c:	8f 93       	push	r24
     50e:	9f 93       	push	r25
     510:	af 93       	push	r26
     512:	bf 93       	push	r27
     514:	cf 93       	push	r28
     516:	df 93       	push	r29
     518:	ef 93       	push	r30
     51a:	ff 93       	push	r31
     51c:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
     520:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     524:	0d b6       	in	r0, 0x3d	; 61
     526:	0d 92       	st	X+, r0
     528:	0e b6       	in	r0, 0x3e	; 62
     52a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     52c:	0e 94 4c 0a 	call	0x1498	; 0x1498 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     530:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
     534:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     538:	cd 91       	ld	r28, X+
     53a:	cd bf       	out	0x3d, r28	; 61
     53c:	dd 91       	ld	r29, X+
     53e:	de bf       	out	0x3e, r29	; 62
     540:	ff 91       	pop	r31
     542:	ef 91       	pop	r30
     544:	df 91       	pop	r29
     546:	cf 91       	pop	r28
     548:	bf 91       	pop	r27
     54a:	af 91       	pop	r26
     54c:	9f 91       	pop	r25
     54e:	8f 91       	pop	r24
     550:	7f 91       	pop	r23
     552:	6f 91       	pop	r22
     554:	5f 91       	pop	r21
     556:	4f 91       	pop	r20
     558:	3f 91       	pop	r19
     55a:	2f 91       	pop	r18
     55c:	1f 91       	pop	r17
     55e:	0f 91       	pop	r16
     560:	ff 90       	pop	r15
     562:	ef 90       	pop	r14
     564:	df 90       	pop	r13
     566:	cf 90       	pop	r12
     568:	bf 90       	pop	r11
     56a:	af 90       	pop	r10
     56c:	9f 90       	pop	r9
     56e:	8f 90       	pop	r8
     570:	7f 90       	pop	r7
     572:	6f 90       	pop	r6
     574:	5f 90       	pop	r5
     576:	4f 90       	pop	r4
     578:	3f 90       	pop	r3
     57a:	2f 90       	pop	r2
     57c:	1f 90       	pop	r1
     57e:	0f 90       	pop	r0
     580:	0f be       	out	0x3f, r0	; 63
     582:	0f 90       	pop	r0

	asm volatile ( "ret" );
     584:	08 95       	ret

00000586 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     586:	0f 92       	push	r0
     588:	0f b6       	in	r0, 0x3f	; 63
     58a:	f8 94       	cli
     58c:	0f 92       	push	r0
     58e:	1f 92       	push	r1
     590:	11 24       	eor	r1, r1
     592:	2f 92       	push	r2
     594:	3f 92       	push	r3
     596:	4f 92       	push	r4
     598:	5f 92       	push	r5
     59a:	6f 92       	push	r6
     59c:	7f 92       	push	r7
     59e:	8f 92       	push	r8
     5a0:	9f 92       	push	r9
     5a2:	af 92       	push	r10
     5a4:	bf 92       	push	r11
     5a6:	cf 92       	push	r12
     5a8:	df 92       	push	r13
     5aa:	ef 92       	push	r14
     5ac:	ff 92       	push	r15
     5ae:	0f 93       	push	r16
     5b0:	1f 93       	push	r17
     5b2:	2f 93       	push	r18
     5b4:	3f 93       	push	r19
     5b6:	4f 93       	push	r20
     5b8:	5f 93       	push	r21
     5ba:	6f 93       	push	r22
     5bc:	7f 93       	push	r23
     5be:	8f 93       	push	r24
     5c0:	9f 93       	push	r25
     5c2:	af 93       	push	r26
     5c4:	bf 93       	push	r27
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	ef 93       	push	r30
     5cc:	ff 93       	push	r31
     5ce:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
     5d2:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     5d6:	0d b6       	in	r0, 0x3d	; 61
     5d8:	0d 92       	st	X+, r0
     5da:	0e b6       	in	r0, 0x3e	; 62
     5dc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5de:	0e 94 b1 08 	call	0x1162	; 0x1162 <xTaskIncrementTick>
     5e2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     5e4:	0e 94 4c 0a 	call	0x1498	; 0x1498 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     5e8:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
     5ec:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     5f0:	cd 91       	ld	r28, X+
     5f2:	cd bf       	out	0x3d, r28	; 61
     5f4:	dd 91       	ld	r29, X+
     5f6:	de bf       	out	0x3e, r29	; 62
     5f8:	ff 91       	pop	r31
     5fa:	ef 91       	pop	r30
     5fc:	df 91       	pop	r29
     5fe:	cf 91       	pop	r28
     600:	bf 91       	pop	r27
     602:	af 91       	pop	r26
     604:	9f 91       	pop	r25
     606:	8f 91       	pop	r24
     608:	7f 91       	pop	r23
     60a:	6f 91       	pop	r22
     60c:	5f 91       	pop	r21
     60e:	4f 91       	pop	r20
     610:	3f 91       	pop	r19
     612:	2f 91       	pop	r18
     614:	1f 91       	pop	r17
     616:	0f 91       	pop	r16
     618:	ff 90       	pop	r15
     61a:	ef 90       	pop	r14
     61c:	df 90       	pop	r13
     61e:	cf 90       	pop	r12
     620:	bf 90       	pop	r11
     622:	af 90       	pop	r10
     624:	9f 90       	pop	r9
     626:	8f 90       	pop	r8
     628:	7f 90       	pop	r7
     62a:	6f 90       	pop	r6
     62c:	5f 90       	pop	r5
     62e:	4f 90       	pop	r4
     630:	3f 90       	pop	r3
     632:	2f 90       	pop	r2
     634:	1f 90       	pop	r1
     636:	0f 90       	pop	r0
     638:	0f be       	out	0x3f, r0	; 63
     63a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     63c:	08 95       	ret

0000063e <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     63e:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYieldFromTick>
		asm volatile ( "reti" );
     642:	18 95       	reti

00000644 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     644:	cf 93       	push	r28
     646:	df 93       	push	r29
     648:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     64a:	ae e7       	ldi	r26, 0x7E	; 126
     64c:	b0 e0       	ldi	r27, 0x00	; 0
     64e:	01 c0       	rjmp	.+2      	; 0x652 <prvInsertBlockIntoFreeList+0xe>
     650:	df 01       	movw	r26, r30
     652:	ed 91       	ld	r30, X+
     654:	fc 91       	ld	r31, X
     656:	11 97       	sbiw	r26, 0x01	; 1
     658:	ec 17       	cp	r30, r28
     65a:	fd 07       	cpc	r31, r29
     65c:	c8 f3       	brcs	.-14     	; 0x650 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     65e:	12 96       	adiw	r26, 0x02	; 2
     660:	2d 91       	ld	r18, X+
     662:	3c 91       	ld	r19, X
     664:	13 97       	sbiw	r26, 0x03	; 3
     666:	cd 01       	movw	r24, r26
     668:	82 0f       	add	r24, r18
     66a:	93 1f       	adc	r25, r19
     66c:	c8 17       	cp	r28, r24
     66e:	d9 07       	cpc	r29, r25
     670:	91 f0       	breq	.+36     	; 0x696 <prvInsertBlockIntoFreeList+0x52>
     672:	8a 81       	ldd	r24, Y+2	; 0x02
     674:	9b 81       	ldd	r25, Y+3	; 0x03
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     676:	9e 01       	movw	r18, r28
     678:	28 0f       	add	r18, r24
     67a:	39 1f       	adc	r19, r25
     67c:	e2 17       	cp	r30, r18
     67e:	f3 07       	cpc	r31, r19
     680:	c9 f0       	breq	.+50     	; 0x6b4 <prvInsertBlockIntoFreeList+0x70>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     682:	f9 83       	std	Y+1, r31	; 0x01
     684:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     686:	ca 17       	cp	r28, r26
     688:	db 07       	cpc	r29, r27
     68a:	11 f0       	breq	.+4      	; 0x690 <prvInsertBlockIntoFreeList+0x4c>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     68c:	cd 93       	st	X+, r28
     68e:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	08 95       	ret
	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     696:	8a 81       	ldd	r24, Y+2	; 0x02
     698:	9b 81       	ldd	r25, Y+3	; 0x03
     69a:	82 0f       	add	r24, r18
     69c:	93 1f       	adc	r25, r19
     69e:	13 96       	adiw	r26, 0x03	; 3
     6a0:	9c 93       	st	X, r25
     6a2:	8e 93       	st	-X, r24
     6a4:	12 97       	sbiw	r26, 0x02	; 2
     6a6:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     6a8:	9e 01       	movw	r18, r28
     6aa:	28 0f       	add	r18, r24
     6ac:	39 1f       	adc	r19, r25
     6ae:	e2 17       	cp	r30, r18
     6b0:	f3 07       	cpc	r31, r19
     6b2:	39 f7       	brne	.-50     	; 0x682 <prvInsertBlockIntoFreeList+0x3e>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     6b4:	20 91 7c 00 	lds	r18, 0x007C	; 0x80007c <pxEnd>
     6b8:	30 91 7d 00 	lds	r19, 0x007D	; 0x80007d <pxEnd+0x1>
     6bc:	e2 17       	cp	r30, r18
     6be:	f3 07       	cpc	r31, r19
     6c0:	01 f3       	breq	.-64     	; 0x682 <prvInsertBlockIntoFreeList+0x3e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     6c2:	22 81       	ldd	r18, Z+2	; 0x02
     6c4:	33 81       	ldd	r19, Z+3	; 0x03
     6c6:	82 0f       	add	r24, r18
     6c8:	93 1f       	adc	r25, r19
     6ca:	9b 83       	std	Y+3, r25	; 0x03
     6cc:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     6ce:	80 81       	ld	r24, Z
     6d0:	91 81       	ldd	r25, Z+1	; 0x01
     6d2:	99 83       	std	Y+1, r25	; 0x01
     6d4:	88 83       	st	Y, r24
     6d6:	d7 cf       	rjmp	.-82     	; 0x686 <prvInsertBlockIntoFreeList+0x42>

000006d8 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6d8:	cf 92       	push	r12
     6da:	df 92       	push	r13
     6dc:	ef 92       	push	r14
     6de:	ff 92       	push	r15
     6e0:	0f 93       	push	r16
     6e2:	1f 93       	push	r17
     6e4:	cf 93       	push	r28
     6e6:	df 93       	push	r29
     6e8:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     6ea:	0e 94 a1 08 	call	0x1142	; 0x1142 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     6ee:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <pxEnd>
     6f2:	90 91 7d 00 	lds	r25, 0x007D	; 0x80007d <pxEnd+0x1>
     6f6:	89 2b       	or	r24, r25
     6f8:	09 f4       	brne	.+2      	; 0x6fc <pvPortMalloc+0x24>
     6fa:	76 c0       	rjmp	.+236    	; 0x7e8 <pvPortMalloc+0x110>
     6fc:	c0 90 76 00 	lds	r12, 0x0076	; 0x800076 <__data_end>
     700:	d0 90 77 00 	lds	r13, 0x0077	; 0x800077 <__data_end+0x1>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     704:	c6 01       	movw	r24, r12
     706:	8c 23       	and	r24, r28
     708:	9d 23       	and	r25, r29
     70a:	89 2b       	or	r24, r25
     70c:	09 f0       	breq	.+2      	; 0x710 <pvPortMalloc+0x38>
     70e:	51 c0       	rjmp	.+162    	; 0x7b2 <pvPortMalloc+0xda>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     710:	20 97       	sbiw	r28, 0x00	; 0
     712:	09 f4       	brne	.+2      	; 0x716 <pvPortMalloc+0x3e>
     714:	4e c0       	rjmp	.+156    	; 0x7b2 <pvPortMalloc+0xda>
			{
				xWantedSize += xHeapStructSize;
     716:	be 01       	movw	r22, r28
     718:	6c 5f       	subi	r22, 0xFC	; 252
     71a:	7f 4f       	sbci	r23, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     71c:	09 f4       	brne	.+2      	; 0x720 <pvPortMalloc+0x48>
     71e:	49 c0       	rjmp	.+146    	; 0x7b2 <pvPortMalloc+0xda>
     720:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <xFreeBytesRemaining>
     724:	10 91 7b 00 	lds	r17, 0x007B	; 0x80007b <xFreeBytesRemaining+0x1>
     728:	06 17       	cp	r16, r22
     72a:	17 07       	cpc	r17, r23
     72c:	08 f4       	brcc	.+2      	; 0x730 <pvPortMalloc+0x58>
     72e:	41 c0       	rjmp	.+130    	; 0x7b2 <pvPortMalloc+0xda>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     730:	c0 91 7e 00 	lds	r28, 0x007E	; 0x80007e <xStart>
     734:	d0 91 7f 00 	lds	r29, 0x007F	; 0x80007f <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     738:	ee e7       	ldi	r30, 0x7E	; 126
     73a:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     73c:	07 c0       	rjmp	.+14     	; 0x74c <pvPortMalloc+0x74>
     73e:	28 81       	ld	r18, Y
     740:	39 81       	ldd	r19, Y+1	; 0x01
     742:	21 15       	cp	r18, r1
     744:	31 05       	cpc	r19, r1
     746:	39 f0       	breq	.+14     	; 0x756 <pvPortMalloc+0x7e>
     748:	fe 01       	movw	r30, r28
     74a:	e9 01       	movw	r28, r18
     74c:	4a 81       	ldd	r20, Y+2	; 0x02
     74e:	5b 81       	ldd	r21, Y+3	; 0x03
     750:	46 17       	cp	r20, r22
     752:	57 07       	cpc	r21, r23
     754:	a0 f3       	brcs	.-24     	; 0x73e <pvPortMalloc+0x66>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     756:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <pxEnd>
     75a:	90 91 7d 00 	lds	r25, 0x007D	; 0x80007d <pxEnd+0x1>
     75e:	c8 17       	cp	r28, r24
     760:	d9 07       	cpc	r29, r25
     762:	39 f1       	breq	.+78     	; 0x7b2 <pvPortMalloc+0xda>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     764:	e0 80       	ld	r14, Z
     766:	f1 80       	ldd	r15, Z+1	; 0x01
     768:	84 e0       	ldi	r24, 0x04	; 4
     76a:	e8 0e       	add	r14, r24
     76c:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     76e:	88 81       	ld	r24, Y
     770:	99 81       	ldd	r25, Y+1	; 0x01
     772:	91 83       	std	Z+1, r25	; 0x01
     774:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     776:	9a 01       	movw	r18, r20
     778:	26 1b       	sub	r18, r22
     77a:	37 0b       	sbc	r19, r23
     77c:	29 30       	cpi	r18, 0x09	; 9
     77e:	31 05       	cpc	r19, r1
     780:	30 f5       	brcc	.+76     	; 0x7ce <pvPortMalloc+0xf6>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     782:	04 1b       	sub	r16, r20
     784:	15 0b       	sbc	r17, r21
     786:	10 93 7b 00 	sts	0x007B, r17	; 0x80007b <xFreeBytesRemaining+0x1>
     78a:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     78e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <xMinimumEverFreeBytesRemaining>
     792:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <xMinimumEverFreeBytesRemaining+0x1>
     796:	08 17       	cp	r16, r24
     798:	19 07       	cpc	r17, r25
     79a:	20 f4       	brcc	.+8      	; 0x7a4 <pvPortMalloc+0xcc>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     79c:	10 93 79 00 	sts	0x0079, r17	; 0x800079 <xMinimumEverFreeBytesRemaining+0x1>
     7a0:	00 93 78 00 	sts	0x0078, r16	; 0x800078 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     7a4:	4c 29       	or	r20, r12
     7a6:	5d 29       	or	r21, r13
     7a8:	5b 83       	std	Y+3, r21	; 0x03
     7aa:	4a 83       	std	Y+2, r20	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     7ac:	19 82       	std	Y+1, r1	; 0x01
     7ae:	18 82       	st	Y, r1
     7b0:	02 c0       	rjmp	.+4      	; 0x7b6 <pvPortMalloc+0xde>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     7b2:	e1 2c       	mov	r14, r1
     7b4:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     7b6:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     7ba:	c7 01       	movw	r24, r14
     7bc:	df 91       	pop	r29
     7be:	cf 91       	pop	r28
     7c0:	1f 91       	pop	r17
     7c2:	0f 91       	pop	r16
     7c4:	ff 90       	pop	r15
     7c6:	ef 90       	pop	r14
     7c8:	df 90       	pop	r13
     7ca:	cf 90       	pop	r12
     7cc:	08 95       	ret
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     7ce:	ce 01       	movw	r24, r28
     7d0:	86 0f       	add	r24, r22
     7d2:	97 1f       	adc	r25, r23
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     7d4:	fc 01       	movw	r30, r24
     7d6:	33 83       	std	Z+3, r19	; 0x03
     7d8:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     7da:	7b 83       	std	Y+3, r23	; 0x03
     7dc:	6a 83       	std	Y+2, r22	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     7de:	0e 94 22 03 	call	0x644	; 0x644 <prvInsertBlockIntoFreeList>
     7e2:	4a 81       	ldd	r20, Y+2	; 0x02
     7e4:	5b 81       	ldd	r21, Y+3	; 0x03
     7e6:	cd cf       	rjmp	.-102    	; 0x782 <pvPortMalloc+0xaa>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     7e8:	82 e8       	ldi	r24, 0x82	; 130
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	90 93 7f 00 	sts	0x007F, r25	; 0x80007f <xStart+0x1>
     7f0:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <xStart>
	xStart.xBlockSize = ( size_t ) 0;
     7f4:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <xStart+0x3>
     7f8:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <xStart+0x2>
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     7fc:	2a e5       	ldi	r18, 0x5A	; 90
     7fe:	36 e0       	ldi	r19, 0x06	; 6
     800:	30 93 7d 00 	sts	0x007D, r19	; 0x80007d <pxEnd+0x1>
     804:	20 93 7c 00 	sts	0x007C, r18	; 0x80007c <pxEnd>
	pxEnd->xBlockSize = 0;
     808:	10 92 5d 06 	sts	0x065D, r1	; 0x80065d <ucHeap+0x5db>
     80c:	10 92 5c 06 	sts	0x065C, r1	; 0x80065c <ucHeap+0x5da>
	pxEnd->pxNextFreeBlock = NULL;
     810:	10 92 5b 06 	sts	0x065B, r1	; 0x80065b <ucHeap+0x5d9>
     814:	10 92 5a 06 	sts	0x065A, r1	; 0x80065a <ucHeap+0x5d8>

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     818:	88 ed       	ldi	r24, 0xD8	; 216
     81a:	95 e0       	ldi	r25, 0x05	; 5
     81c:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <ucHeap+0x3>
     820:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <ucHeap+0x2>
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     824:	30 93 83 00 	sts	0x0083, r19	; 0x800083 <ucHeap+0x1>
     828:	20 93 82 00 	sts	0x0082, r18	; 0x800082 <ucHeap>

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     82c:	90 93 79 00 	sts	0x0079, r25	; 0x800079 <xMinimumEverFreeBytesRemaining+0x1>
     830:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     834:	90 93 7b 00 	sts	0x007B, r25	; 0x80007b <xFreeBytesRemaining+0x1>
     838:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	90 e8       	ldi	r25, 0x80	; 128
     840:	90 93 77 00 	sts	0x0077, r25	; 0x800077 <__data_end+0x1>
     844:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__data_end>
     848:	c1 2c       	mov	r12, r1
     84a:	80 e8       	ldi	r24, 0x80	; 128
     84c:	d8 2e       	mov	r13, r24
     84e:	5a cf       	rjmp	.-332    	; 0x704 <pvPortMalloc+0x2c>

00000850 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     850:	cf 93       	push	r28
     852:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     854:	00 97       	sbiw	r24, 0x00	; 0
     856:	89 f0       	breq	.+34     	; 0x87a <__stack+0x1b>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     858:	ec 01       	movw	r28, r24
     85a:	24 97       	sbiw	r28, 0x04	; 4
     85c:	8a 81       	ldd	r24, Y+2	; 0x02
     85e:	9b 81       	ldd	r25, Y+3	; 0x03
     860:	20 91 76 00 	lds	r18, 0x0076	; 0x800076 <__data_end>
     864:	30 91 77 00 	lds	r19, 0x0077	; 0x800077 <__data_end+0x1>
     868:	ac 01       	movw	r20, r24
     86a:	42 23       	and	r20, r18
     86c:	53 23       	and	r21, r19
     86e:	45 2b       	or	r20, r21
     870:	21 f0       	breq	.+8      	; 0x87a <__stack+0x1b>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     872:	48 81       	ld	r20, Y
     874:	59 81       	ldd	r21, Y+1	; 0x01
     876:	45 2b       	or	r20, r21
     878:	19 f0       	breq	.+6      	; 0x880 <__stack+0x21>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     87a:	df 91       	pop	r29
     87c:	cf 91       	pop	r28
     87e:	08 95       	ret
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     880:	20 95       	com	r18
     882:	30 95       	com	r19
     884:	82 23       	and	r24, r18
     886:	93 23       	and	r25, r19
     888:	9b 83       	std	Y+3, r25	; 0x03
     88a:	8a 83       	std	Y+2, r24	; 0x02

				vTaskSuspendAll();
     88c:	0e 94 a1 08 	call	0x1142	; 0x1142 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     890:	20 91 7a 00 	lds	r18, 0x007A	; 0x80007a <xFreeBytesRemaining>
     894:	30 91 7b 00 	lds	r19, 0x007B	; 0x80007b <xFreeBytesRemaining+0x1>
     898:	8a 81       	ldd	r24, Y+2	; 0x02
     89a:	9b 81       	ldd	r25, Y+3	; 0x03
     89c:	82 0f       	add	r24, r18
     89e:	93 1f       	adc	r25, r19
     8a0:	90 93 7b 00 	sts	0x007B, r25	; 0x80007b <xFreeBytesRemaining+0x1>
     8a4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     8a8:	ce 01       	movw	r24, r28
     8aa:	0e 94 22 03 	call	0x644	; 0x644 <prvInsertBlockIntoFreeList>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     8ae:	df 91       	pop	r29
     8b0:	cf 91       	pop	r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
     8b2:	0c 94 8b 09 	jmp	0x1316	; 0x1316 <xTaskResumeAll>

000008b6 <prvCopyDataToQueue>:
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     8b6:	0f 93       	push	r16
     8b8:	1f 93       	push	r17
     8ba:	cf 93       	push	r28
     8bc:	df 93       	push	r29
     8be:	ec 01       	movw	r28, r24
     8c0:	04 2f       	mov	r16, r20
     8c2:	1a 8d       	ldd	r17, Y+26	; 0x1a
     8c4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     8c6:	41 11       	cpse	r20, r1
     8c8:	0d c0       	rjmp	.+26     	; 0x8e4 <prvCopyDataToQueue+0x2e>
     8ca:	88 81       	ld	r24, Y
     8cc:	99 81       	ldd	r25, Y+1	; 0x01
     8ce:	89 2b       	or	r24, r25
     8d0:	09 f4       	brne	.+2      	; 0x8d4 <prvCopyDataToQueue+0x1e>
     8d2:	43 c0       	rjmp	.+134    	; 0x95a <prvCopyDataToQueue+0xa4>
     8d4:	1f 5f       	subi	r17, 0xFF	; 255
     8d6:	80 e0       	ldi	r24, 0x00	; 0
     8d8:	1a 8f       	std	Y+26, r17	; 0x1a
     8da:	df 91       	pop	r29
     8dc:	cf 91       	pop	r28
     8de:	1f 91       	pop	r17
     8e0:	0f 91       	pop	r16
     8e2:	08 95       	ret
     8e4:	50 e0       	ldi	r21, 0x00	; 0
     8e6:	01 11       	cpse	r16, r1
     8e8:	15 c0       	rjmp	.+42     	; 0x914 <prvCopyDataToQueue+0x5e>
     8ea:	8c 81       	ldd	r24, Y+4	; 0x04
     8ec:	9d 81       	ldd	r25, Y+5	; 0x05
     8ee:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <memcpy>
     8f2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8f4:	8c 81       	ldd	r24, Y+4	; 0x04
     8f6:	9d 81       	ldd	r25, Y+5	; 0x05
     8f8:	82 0f       	add	r24, r18
     8fa:	91 1d       	adc	r25, r1
     8fc:	9d 83       	std	Y+5, r25	; 0x05
     8fe:	8c 83       	std	Y+4, r24	; 0x04
     900:	2a 81       	ldd	r18, Y+2	; 0x02
     902:	3b 81       	ldd	r19, Y+3	; 0x03
     904:	82 17       	cp	r24, r18
     906:	93 07       	cpc	r25, r19
     908:	28 f3       	brcs	.-54     	; 0x8d4 <prvCopyDataToQueue+0x1e>
     90a:	88 81       	ld	r24, Y
     90c:	99 81       	ldd	r25, Y+1	; 0x01
     90e:	9d 83       	std	Y+5, r25	; 0x05
     910:	8c 83       	std	Y+4, r24	; 0x04
     912:	e0 cf       	rjmp	.-64     	; 0x8d4 <prvCopyDataToQueue+0x1e>
     914:	8e 81       	ldd	r24, Y+6	; 0x06
     916:	9f 81       	ldd	r25, Y+7	; 0x07
     918:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <memcpy>
     91c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     91e:	90 e0       	ldi	r25, 0x00	; 0
     920:	91 95       	neg	r25
     922:	81 95       	neg	r24
     924:	91 09       	sbc	r25, r1
     926:	2e 81       	ldd	r18, Y+6	; 0x06
     928:	3f 81       	ldd	r19, Y+7	; 0x07
     92a:	28 0f       	add	r18, r24
     92c:	39 1f       	adc	r19, r25
     92e:	3f 83       	std	Y+7, r19	; 0x07
     930:	2e 83       	std	Y+6, r18	; 0x06
     932:	48 81       	ld	r20, Y
     934:	59 81       	ldd	r21, Y+1	; 0x01
     936:	24 17       	cp	r18, r20
     938:	35 07       	cpc	r19, r21
     93a:	30 f4       	brcc	.+12     	; 0x948 <prvCopyDataToQueue+0x92>
     93c:	2a 81       	ldd	r18, Y+2	; 0x02
     93e:	3b 81       	ldd	r19, Y+3	; 0x03
     940:	82 0f       	add	r24, r18
     942:	93 1f       	adc	r25, r19
     944:	9f 83       	std	Y+7, r25	; 0x07
     946:	8e 83       	std	Y+6, r24	; 0x06
     948:	02 30       	cpi	r16, 0x02	; 2
     94a:	21 f6       	brne	.-120    	; 0x8d4 <prvCopyDataToQueue+0x1e>
     94c:	11 23       	and	r17, r17
     94e:	11 f0       	breq	.+4      	; 0x954 <prvCopyDataToQueue+0x9e>
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	c2 cf       	rjmp	.-124    	; 0x8d8 <prvCopyDataToQueue+0x22>
     954:	11 e0       	ldi	r17, 0x01	; 1
     956:	80 e0       	ldi	r24, 0x00	; 0
     958:	bf cf       	rjmp	.-130    	; 0x8d8 <prvCopyDataToQueue+0x22>
     95a:	8a 81       	ldd	r24, Y+2	; 0x02
     95c:	9b 81       	ldd	r25, Y+3	; 0x03
     95e:	0e 94 96 0b 	call	0x172c	; 0x172c <xTaskPriorityDisinherit>
     962:	1b 82       	std	Y+3, r1	; 0x03
     964:	1a 82       	std	Y+2, r1	; 0x02
     966:	1f 5f       	subi	r17, 0xFF	; 255
     968:	b7 cf       	rjmp	.-146    	; 0x8d8 <prvCopyDataToQueue+0x22>

0000096a <prvCopyDataFromQueue>:
     96a:	fc 01       	movw	r30, r24
     96c:	cb 01       	movw	r24, r22
     96e:	44 8d       	ldd	r20, Z+28	; 0x1c
     970:	44 23       	and	r20, r20
     972:	91 f0       	breq	.+36     	; 0x998 <prvCopyDataFromQueue+0x2e>
     974:	50 e0       	ldi	r21, 0x00	; 0
     976:	66 81       	ldd	r22, Z+6	; 0x06
     978:	77 81       	ldd	r23, Z+7	; 0x07
     97a:	64 0f       	add	r22, r20
     97c:	75 1f       	adc	r23, r21
     97e:	77 83       	std	Z+7, r23	; 0x07
     980:	66 83       	std	Z+6, r22	; 0x06
     982:	22 81       	ldd	r18, Z+2	; 0x02
     984:	33 81       	ldd	r19, Z+3	; 0x03
     986:	62 17       	cp	r22, r18
     988:	73 07       	cpc	r23, r19
     98a:	20 f0       	brcs	.+8      	; 0x994 <prvCopyDataFromQueue+0x2a>
     98c:	60 81       	ld	r22, Z
     98e:	71 81       	ldd	r23, Z+1	; 0x01
     990:	77 83       	std	Z+7, r23	; 0x07
     992:	66 83       	std	Z+6, r22	; 0x06
     994:	0c 94 e9 0b 	jmp	0x17d2	; 0x17d2 <memcpy>
     998:	08 95       	ret

0000099a <prvUnlockQueue>:
     99a:	ef 92       	push	r14
     99c:	ff 92       	push	r15
     99e:	0f 93       	push	r16
     9a0:	1f 93       	push	r17
     9a2:	cf 93       	push	r28
     9a4:	8c 01       	movw	r16, r24
     9a6:	0f b6       	in	r0, 0x3f	; 63
     9a8:	f8 94       	cli
     9aa:	0f 92       	push	r0
     9ac:	fc 01       	movw	r30, r24
     9ae:	c6 8d       	ldd	r28, Z+30	; 0x1e
     9b0:	1c 16       	cp	r1, r28
     9b2:	c4 f4       	brge	.+48     	; 0x9e4 <prvUnlockQueue+0x4a>
     9b4:	fc 01       	movw	r30, r24
     9b6:	81 89       	ldd	r24, Z+17	; 0x11
     9b8:	88 23       	and	r24, r24
     9ba:	a1 f0       	breq	.+40     	; 0x9e4 <prvUnlockQueue+0x4a>
     9bc:	78 01       	movw	r14, r16
     9be:	f1 e1       	ldi	r31, 0x11	; 17
     9c0:	ef 0e       	add	r14, r31
     9c2:	f1 1c       	adc	r15, r1
     9c4:	06 c0       	rjmp	.+12     	; 0x9d2 <prvUnlockQueue+0x38>
     9c6:	c1 50       	subi	r28, 0x01	; 1
     9c8:	69 f0       	breq	.+26     	; 0x9e4 <prvUnlockQueue+0x4a>
     9ca:	f8 01       	movw	r30, r16
     9cc:	81 89       	ldd	r24, Z+17	; 0x11
     9ce:	88 23       	and	r24, r24
     9d0:	49 f0       	breq	.+18     	; 0x9e4 <prvUnlockQueue+0x4a>
     9d2:	c7 01       	movw	r24, r14
     9d4:	0e 94 a1 0a 	call	0x1542	; 0x1542 <xTaskRemoveFromEventList>
     9d8:	88 23       	and	r24, r24
     9da:	a9 f3       	breq	.-22     	; 0x9c6 <prvUnlockQueue+0x2c>
     9dc:	0e 94 2f 0b 	call	0x165e	; 0x165e <vTaskMissedYield>
     9e0:	c1 50       	subi	r28, 0x01	; 1
     9e2:	99 f7       	brne	.-26     	; 0x9ca <prvUnlockQueue+0x30>
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
     9e6:	f8 01       	movw	r30, r16
     9e8:	86 8f       	std	Z+30, r24	; 0x1e
     9ea:	0f 90       	pop	r0
     9ec:	0f be       	out	0x3f, r0	; 63
     9ee:	0f b6       	in	r0, 0x3f	; 63
     9f0:	f8 94       	cli
     9f2:	0f 92       	push	r0
     9f4:	c5 8d       	ldd	r28, Z+29	; 0x1d
     9f6:	1c 16       	cp	r1, r28
     9f8:	c4 f4       	brge	.+48     	; 0xa2a <prvUnlockQueue+0x90>
     9fa:	f8 01       	movw	r30, r16
     9fc:	80 85       	ldd	r24, Z+8	; 0x08
     9fe:	88 23       	and	r24, r24
     a00:	a1 f0       	breq	.+40     	; 0xa2a <prvUnlockQueue+0x90>
     a02:	78 01       	movw	r14, r16
     a04:	f8 e0       	ldi	r31, 0x08	; 8
     a06:	ef 0e       	add	r14, r31
     a08:	f1 1c       	adc	r15, r1
     a0a:	06 c0       	rjmp	.+12     	; 0xa18 <prvUnlockQueue+0x7e>
     a0c:	c1 50       	subi	r28, 0x01	; 1
     a0e:	69 f0       	breq	.+26     	; 0xa2a <prvUnlockQueue+0x90>
     a10:	f8 01       	movw	r30, r16
     a12:	80 85       	ldd	r24, Z+8	; 0x08
     a14:	88 23       	and	r24, r24
     a16:	49 f0       	breq	.+18     	; 0xa2a <prvUnlockQueue+0x90>
     a18:	c7 01       	movw	r24, r14
     a1a:	0e 94 a1 0a 	call	0x1542	; 0x1542 <xTaskRemoveFromEventList>
     a1e:	88 23       	and	r24, r24
     a20:	a9 f3       	breq	.-22     	; 0xa0c <prvUnlockQueue+0x72>
     a22:	0e 94 2f 0b 	call	0x165e	; 0x165e <vTaskMissedYield>
     a26:	c1 50       	subi	r28, 0x01	; 1
     a28:	99 f7       	brne	.-26     	; 0xa10 <prvUnlockQueue+0x76>
     a2a:	8f ef       	ldi	r24, 0xFF	; 255
     a2c:	f8 01       	movw	r30, r16
     a2e:	85 8f       	std	Z+29, r24	; 0x1d
     a30:	0f 90       	pop	r0
     a32:	0f be       	out	0x3f, r0	; 63
     a34:	cf 91       	pop	r28
     a36:	1f 91       	pop	r17
     a38:	0f 91       	pop	r16
     a3a:	ff 90       	pop	r15
     a3c:	ef 90       	pop	r14
     a3e:	08 95       	ret

00000a40 <xQueueGenericReset>:
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	ec 01       	movw	r28, r24
     a46:	0f b6       	in	r0, 0x3f	; 63
     a48:	f8 94       	cli
     a4a:	0f 92       	push	r0
     a4c:	28 81       	ld	r18, Y
     a4e:	39 81       	ldd	r19, Y+1	; 0x01
     a50:	9b 8d       	ldd	r25, Y+27	; 0x1b
     a52:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a54:	94 9f       	mul	r25, r20
     a56:	c0 01       	movw	r24, r0
     a58:	11 24       	eor	r1, r1
     a5a:	f9 01       	movw	r30, r18
     a5c:	e8 0f       	add	r30, r24
     a5e:	f9 1f       	adc	r31, r25
     a60:	fb 83       	std	Y+3, r31	; 0x03
     a62:	ea 83       	std	Y+2, r30	; 0x02
     a64:	1a 8e       	std	Y+26, r1	; 0x1a
     a66:	3d 83       	std	Y+5, r19	; 0x05
     a68:	2c 83       	std	Y+4, r18	; 0x04
     a6a:	84 1b       	sub	r24, r20
     a6c:	91 09       	sbc	r25, r1
     a6e:	82 0f       	add	r24, r18
     a70:	93 1f       	adc	r25, r19
     a72:	9f 83       	std	Y+7, r25	; 0x07
     a74:	8e 83       	std	Y+6, r24	; 0x06
     a76:	8f ef       	ldi	r24, 0xFF	; 255
     a78:	8d 8f       	std	Y+29, r24	; 0x1d
     a7a:	8e 8f       	std	Y+30, r24	; 0x1e
     a7c:	61 11       	cpse	r22, r1
     a7e:	12 c0       	rjmp	.+36     	; 0xaa4 <xQueueGenericReset+0x64>
     a80:	88 85       	ldd	r24, Y+8	; 0x08
     a82:	81 11       	cpse	r24, r1
     a84:	06 c0       	rjmp	.+12     	; 0xa92 <xQueueGenericReset+0x52>
     a86:	0f 90       	pop	r0
     a88:	0f be       	out	0x3f, r0	; 63
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	08 95       	ret
     a92:	ce 01       	movw	r24, r28
     a94:	08 96       	adiw	r24, 0x08	; 8
     a96:	0e 94 a1 0a 	call	0x1542	; 0x1542 <xTaskRemoveFromEventList>
     a9a:	88 23       	and	r24, r24
     a9c:	a1 f3       	breq	.-24     	; 0xa86 <xQueueGenericReset+0x46>
     a9e:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
     aa2:	f1 cf       	rjmp	.-30     	; 0xa86 <xQueueGenericReset+0x46>
     aa4:	ce 01       	movw	r24, r28
     aa6:	08 96       	adiw	r24, 0x08	; 8
     aa8:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
     aac:	ce 01       	movw	r24, r28
     aae:	41 96       	adiw	r24, 0x11	; 17
     ab0:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
     ab4:	0f 90       	pop	r0
     ab6:	0f be       	out	0x3f, r0	; 63
     ab8:	81 e0       	ldi	r24, 0x01	; 1
     aba:	df 91       	pop	r29
     abc:	cf 91       	pop	r28
     abe:	08 95       	ret

00000ac0 <xQueueGenericCreate>:
     ac0:	0f 93       	push	r16
     ac2:	1f 93       	push	r17
     ac4:	cf 93       	push	r28
     ac6:	df 93       	push	r29
     ac8:	08 2f       	mov	r16, r24
     aca:	16 2f       	mov	r17, r22
     acc:	66 23       	and	r22, r22
     ace:	c1 f0       	breq	.+48     	; 0xb00 <xQueueGenericCreate+0x40>
     ad0:	86 9f       	mul	r24, r22
     ad2:	c0 01       	movw	r24, r0
     ad4:	11 24       	eor	r1, r1
     ad6:	4f 96       	adiw	r24, 0x1f	; 31
     ad8:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <pvPortMalloc>
     adc:	ec 01       	movw	r28, r24
     ade:	00 97       	sbiw	r24, 0x00	; 0
     ae0:	49 f0       	breq	.+18     	; 0xaf4 <xQueueGenericCreate+0x34>
     ae2:	4f 96       	adiw	r24, 0x1f	; 31
     ae4:	99 83       	std	Y+1, r25	; 0x01
     ae6:	88 83       	st	Y, r24
     ae8:	0b 8f       	std	Y+27, r16	; 0x1b
     aea:	1c 8f       	std	Y+28, r17	; 0x1c
     aec:	61 e0       	ldi	r22, 0x01	; 1
     aee:	ce 01       	movw	r24, r28
     af0:	0e 94 20 05 	call	0xa40	; 0xa40 <xQueueGenericReset>
     af4:	ce 01       	movw	r24, r28
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	1f 91       	pop	r17
     afc:	0f 91       	pop	r16
     afe:	08 95       	ret
     b00:	8f e1       	ldi	r24, 0x1F	; 31
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <pvPortMalloc>
     b08:	ec 01       	movw	r28, r24
     b0a:	89 2b       	or	r24, r25
     b0c:	99 f3       	breq	.-26     	; 0xaf4 <xQueueGenericCreate+0x34>
     b0e:	d9 83       	std	Y+1, r29	; 0x01
     b10:	c8 83       	st	Y, r28
     b12:	0b 8f       	std	Y+27, r16	; 0x1b
     b14:	1c 8f       	std	Y+28, r17	; 0x1c
     b16:	61 e0       	ldi	r22, 0x01	; 1
     b18:	ce 01       	movw	r24, r28
     b1a:	0e 94 20 05 	call	0xa40	; 0xa40 <xQueueGenericReset>
     b1e:	ce 01       	movw	r24, r28
     b20:	df 91       	pop	r29
     b22:	cf 91       	pop	r28
     b24:	1f 91       	pop	r17
     b26:	0f 91       	pop	r16
     b28:	08 95       	ret

00000b2a <xQueueGenericSend>:
     b2a:	bf 92       	push	r11
     b2c:	cf 92       	push	r12
     b2e:	df 92       	push	r13
     b30:	ef 92       	push	r14
     b32:	ff 92       	push	r15
     b34:	0f 93       	push	r16
     b36:	1f 93       	push	r17
     b38:	cf 93       	push	r28
     b3a:	df 93       	push	r29
     b3c:	00 d0       	rcall	.+0      	; 0xb3e <xQueueGenericSend+0x14>
     b3e:	00 d0       	rcall	.+0      	; 0xb40 <xQueueGenericSend+0x16>
     b40:	1f 92       	push	r1
     b42:	cd b7       	in	r28, 0x3d	; 61
     b44:	de b7       	in	r29, 0x3e	; 62
     b46:	8c 01       	movw	r16, r24
     b48:	6b 01       	movw	r12, r22
     b4a:	5d 83       	std	Y+5, r21	; 0x05
     b4c:	4c 83       	std	Y+4, r20	; 0x04
     b4e:	b2 2e       	mov	r11, r18
     b50:	20 e0       	ldi	r18, 0x00	; 0
     b52:	7c 01       	movw	r14, r24
     b54:	88 e0       	ldi	r24, 0x08	; 8
     b56:	e8 0e       	add	r14, r24
     b58:	f1 1c       	adc	r15, r1
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	0f 92       	push	r0
     b60:	f8 01       	movw	r30, r16
     b62:	92 8d       	ldd	r25, Z+26	; 0x1a
     b64:	83 8d       	ldd	r24, Z+27	; 0x1b
     b66:	98 17       	cp	r25, r24
     b68:	08 f4       	brcc	.+2      	; 0xb6c <xQueueGenericSend+0x42>
     b6a:	53 c0       	rjmp	.+166    	; 0xc12 <xQueueGenericSend+0xe8>
     b6c:	f2 e0       	ldi	r31, 0x02	; 2
     b6e:	bf 16       	cp	r11, r31
     b70:	09 f4       	brne	.+2      	; 0xb74 <xQueueGenericSend+0x4a>
     b72:	4f c0       	rjmp	.+158    	; 0xc12 <xQueueGenericSend+0xe8>
     b74:	8c 81       	ldd	r24, Y+4	; 0x04
     b76:	9d 81       	ldd	r25, Y+5	; 0x05
     b78:	89 2b       	or	r24, r25
     b7a:	09 f4       	brne	.+2      	; 0xb7e <xQueueGenericSend+0x54>
     b7c:	67 c0       	rjmp	.+206    	; 0xc4c <xQueueGenericSend+0x122>
     b7e:	22 23       	and	r18, r18
     b80:	09 f4       	brne	.+2      	; 0xb84 <xQueueGenericSend+0x5a>
     b82:	3e c0       	rjmp	.+124    	; 0xc00 <xQueueGenericSend+0xd6>
     b84:	0f 90       	pop	r0
     b86:	0f be       	out	0x3f, r0	; 63
     b88:	0e 94 a1 08 	call	0x1142	; 0x1142 <vTaskSuspendAll>
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	0f 92       	push	r0
     b92:	f8 01       	movw	r30, r16
     b94:	85 8d       	ldd	r24, Z+29	; 0x1d
     b96:	8f 3f       	cpi	r24, 0xFF	; 255
     b98:	09 f4       	brne	.+2      	; 0xb9c <xQueueGenericSend+0x72>
     b9a:	39 c0       	rjmp	.+114    	; 0xc0e <xQueueGenericSend+0xe4>
     b9c:	f8 01       	movw	r30, r16
     b9e:	86 8d       	ldd	r24, Z+30	; 0x1e
     ba0:	8f 3f       	cpi	r24, 0xFF	; 255
     ba2:	99 f1       	breq	.+102    	; 0xc0a <xQueueGenericSend+0xe0>
     ba4:	0f 90       	pop	r0
     ba6:	0f be       	out	0x3f, r0	; 63
     ba8:	be 01       	movw	r22, r28
     baa:	6c 5f       	subi	r22, 0xFC	; 252
     bac:	7f 4f       	sbci	r23, 0xFF	; 255
     bae:	ce 01       	movw	r24, r28
     bb0:	01 96       	adiw	r24, 0x01	; 1
     bb2:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <xTaskCheckForTimeOut>
     bb6:	81 11       	cpse	r24, r1
     bb8:	4d c0       	rjmp	.+154    	; 0xc54 <xQueueGenericSend+0x12a>
     bba:	0f b6       	in	r0, 0x3f	; 63
     bbc:	f8 94       	cli
     bbe:	0f 92       	push	r0
     bc0:	f8 01       	movw	r30, r16
     bc2:	92 8d       	ldd	r25, Z+26	; 0x1a
     bc4:	0f 90       	pop	r0
     bc6:	0f be       	out	0x3f, r0	; 63
     bc8:	83 8d       	ldd	r24, Z+27	; 0x1b
     bca:	98 13       	cpse	r25, r24
     bcc:	12 c0       	rjmp	.+36     	; 0xbf2 <xQueueGenericSend+0xc8>
     bce:	6c 81       	ldd	r22, Y+4	; 0x04
     bd0:	7d 81       	ldd	r23, Y+5	; 0x05
     bd2:	c7 01       	movw	r24, r14
     bd4:	0e 94 91 0a 	call	0x1522	; 0x1522 <vTaskPlaceOnEventList>
     bd8:	c8 01       	movw	r24, r16
     bda:	0e 94 cd 04 	call	0x99a	; 0x99a <prvUnlockQueue>
     bde:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
     be2:	88 23       	and	r24, r24
     be4:	11 f0       	breq	.+4      	; 0xbea <xQueueGenericSend+0xc0>
     be6:	21 e0       	ldi	r18, 0x01	; 1
     be8:	b8 cf       	rjmp	.-144    	; 0xb5a <xQueueGenericSend+0x30>
     bea:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
     bee:	21 e0       	ldi	r18, 0x01	; 1
     bf0:	b4 cf       	rjmp	.-152    	; 0xb5a <xQueueGenericSend+0x30>
     bf2:	c8 01       	movw	r24, r16
     bf4:	0e 94 cd 04 	call	0x99a	; 0x99a <prvUnlockQueue>
     bf8:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
     bfc:	21 e0       	ldi	r18, 0x01	; 1
     bfe:	ad cf       	rjmp	.-166    	; 0xb5a <xQueueGenericSend+0x30>
     c00:	ce 01       	movw	r24, r28
     c02:	01 96       	adiw	r24, 0x01	; 1
     c04:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <vTaskSetTimeOutState>
     c08:	bd cf       	rjmp	.-134    	; 0xb84 <xQueueGenericSend+0x5a>
     c0a:	16 8e       	std	Z+30, r1	; 0x1e
     c0c:	cb cf       	rjmp	.-106    	; 0xba4 <xQueueGenericSend+0x7a>
     c0e:	15 8e       	std	Z+29, r1	; 0x1d
     c10:	c5 cf       	rjmp	.-118    	; 0xb9c <xQueueGenericSend+0x72>
     c12:	4b 2d       	mov	r20, r11
     c14:	b6 01       	movw	r22, r12
     c16:	c8 01       	movw	r24, r16
     c18:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <prvCopyDataToQueue>
     c1c:	f8 01       	movw	r30, r16
     c1e:	91 89       	ldd	r25, Z+17	; 0x11
     c20:	91 11       	cpse	r25, r1
     c22:	22 c0       	rjmp	.+68     	; 0xc68 <xQueueGenericSend+0x13e>
     c24:	81 11       	cpse	r24, r1
     c26:	1d c0       	rjmp	.+58     	; 0xc62 <xQueueGenericSend+0x138>
     c28:	0f 90       	pop	r0
     c2a:	0f be       	out	0x3f, r0	; 63
     c2c:	81 e0       	ldi	r24, 0x01	; 1
     c2e:	0f 90       	pop	r0
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	ff 90       	pop	r15
     c42:	ef 90       	pop	r14
     c44:	df 90       	pop	r13
     c46:	cf 90       	pop	r12
     c48:	bf 90       	pop	r11
     c4a:	08 95       	ret
     c4c:	0f 90       	pop	r0
     c4e:	0f be       	out	0x3f, r0	; 63
     c50:	80 e0       	ldi	r24, 0x00	; 0
     c52:	ed cf       	rjmp	.-38     	; 0xc2e <xQueueGenericSend+0x104>
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 cd 04 	call	0x99a	; 0x99a <prvUnlockQueue>
     c5a:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
     c5e:	80 e0       	ldi	r24, 0x00	; 0
     c60:	e6 cf       	rjmp	.-52     	; 0xc2e <xQueueGenericSend+0x104>
     c62:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
     c66:	e0 cf       	rjmp	.-64     	; 0xc28 <xQueueGenericSend+0xfe>
     c68:	c8 01       	movw	r24, r16
     c6a:	41 96       	adiw	r24, 0x11	; 17
     c6c:	0e 94 a1 0a 	call	0x1542	; 0x1542 <xTaskRemoveFromEventList>
     c70:	88 23       	and	r24, r24
     c72:	d1 f2       	breq	.-76     	; 0xc28 <xQueueGenericSend+0xfe>
     c74:	f6 cf       	rjmp	.-20     	; 0xc62 <xQueueGenericSend+0x138>

00000c76 <xQueueCreateMutex>:
     c76:	cf 93       	push	r28
     c78:	df 93       	push	r29
     c7a:	48 2f       	mov	r20, r24
     c7c:	60 e0       	ldi	r22, 0x00	; 0
     c7e:	81 e0       	ldi	r24, 0x01	; 1
     c80:	0e 94 60 05 	call	0xac0	; 0xac0 <xQueueGenericCreate>
     c84:	ec 01       	movw	r28, r24
     c86:	00 97       	sbiw	r24, 0x00	; 0
     c88:	61 f0       	breq	.+24     	; 0xca2 <xQueueCreateMutex+0x2c>
     c8a:	1b 82       	std	Y+3, r1	; 0x03
     c8c:	1a 82       	std	Y+2, r1	; 0x02
     c8e:	19 82       	std	Y+1, r1	; 0x01
     c90:	18 82       	st	Y, r1
     c92:	1e 82       	std	Y+6, r1	; 0x06
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	40 e0       	ldi	r20, 0x00	; 0
     c98:	50 e0       	ldi	r21, 0x00	; 0
     c9a:	60 e0       	ldi	r22, 0x00	; 0
     c9c:	70 e0       	ldi	r23, 0x00	; 0
     c9e:	0e 94 95 05 	call	0xb2a	; 0xb2a <xQueueGenericSend>
     ca2:	ce 01       	movw	r24, r28
     ca4:	df 91       	pop	r29
     ca6:	cf 91       	pop	r28
     ca8:	08 95       	ret

00000caa <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     caa:	af 92       	push	r10
     cac:	bf 92       	push	r11
     cae:	cf 92       	push	r12
     cb0:	df 92       	push	r13
     cb2:	ef 92       	push	r14
     cb4:	ff 92       	push	r15
     cb6:	0f 93       	push	r16
     cb8:	1f 93       	push	r17
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	00 d0       	rcall	.+0      	; 0xcc0 <xQueueGenericReceive+0x16>
     cc0:	00 d0       	rcall	.+0      	; 0xcc2 <xQueueGenericReceive+0x18>
     cc2:	1f 92       	push	r1
     cc4:	cd b7       	in	r28, 0x3d	; 61
     cc6:	de b7       	in	r29, 0x3e	; 62
     cc8:	8c 01       	movw	r16, r24
     cca:	5b 01       	movw	r10, r22
     ccc:	5d 83       	std	Y+5, r21	; 0x05
     cce:	4c 83       	std	Y+4, r20	; 0x04
     cd0:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
     cd2:	20 e0       	ldi	r18, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     cd4:	6c 01       	movw	r12, r24
     cd6:	81 e1       	ldi	r24, 0x11	; 17
     cd8:	c8 0e       	add	r12, r24
     cda:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     ce2:	f8 01       	movw	r30, r16
     ce4:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ce6:	f1 10       	cpse	r15, r1
     ce8:	80 c0       	rjmp	.+256    	; 0xdea <xQueueGenericReceive+0x140>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     cea:	8c 81       	ldd	r24, Y+4	; 0x04
     cec:	9d 81       	ldd	r25, Y+5	; 0x05
     cee:	89 2b       	or	r24, r25
     cf0:	09 f4       	brne	.+2      	; 0xcf4 <xQueueGenericReceive+0x4a>
     cf2:	92 c0       	rjmp	.+292    	; 0xe18 <xQueueGenericReceive+0x16e>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     cf4:	22 23       	and	r18, r18
     cf6:	09 f4       	brne	.+2      	; 0xcfa <xQueueGenericReceive+0x50>
     cf8:	5a c0       	rjmp	.+180    	; 0xdae <xQueueGenericReceive+0x104>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     cfa:	0f 90       	pop	r0
     cfc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     cfe:	0e 94 a1 08 	call	0x1142	; 0x1142 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     d02:	0f b6       	in	r0, 0x3f	; 63
     d04:	f8 94       	cli
     d06:	0f 92       	push	r0
     d08:	f8 01       	movw	r30, r16
     d0a:	85 8d       	ldd	r24, Z+29	; 0x1d
     d0c:	8f 3f       	cpi	r24, 0xFF	; 255
     d0e:	09 f4       	brne	.+2      	; 0xd12 <xQueueGenericReceive+0x68>
     d10:	53 c0       	rjmp	.+166    	; 0xdb8 <xQueueGenericReceive+0x10e>
     d12:	f8 01       	movw	r30, r16
     d14:	86 8d       	ldd	r24, Z+30	; 0x1e
     d16:	8f 3f       	cpi	r24, 0xFF	; 255
     d18:	09 f4       	brne	.+2      	; 0xd1c <xQueueGenericReceive+0x72>
     d1a:	54 c0       	rjmp	.+168    	; 0xdc4 <xQueueGenericReceive+0x11a>
     d1c:	0f 90       	pop	r0
     d1e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d20:	be 01       	movw	r22, r28
     d22:	6c 5f       	subi	r22, 0xFC	; 252
     d24:	7f 4f       	sbci	r23, 0xFF	; 255
     d26:	ce 01       	movw	r24, r28
     d28:	01 96       	adiw	r24, 0x01	; 1
     d2a:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <xTaskCheckForTimeOut>
     d2e:	81 11       	cpse	r24, r1
     d30:	20 c0       	rjmp	.+64     	; 0xd72 <xQueueGenericReceive+0xc8>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d32:	0f b6       	in	r0, 0x3f	; 63
     d34:	f8 94       	cli
     d36:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     d38:	f8 01       	movw	r30, r16
     d3a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     d3c:	0f 90       	pop	r0
     d3e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d40:	81 11       	cpse	r24, r1
     d42:	42 c0       	rjmp	.+132    	; 0xdc8 <xQueueGenericReceive+0x11e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d44:	80 81       	ld	r24, Z
     d46:	91 81       	ldd	r25, Z+1	; 0x01
     d48:	89 2b       	or	r24, r25
     d4a:	09 f4       	brne	.+2      	; 0xd4e <xQueueGenericReceive+0xa4>
     d4c:	44 c0       	rjmp	.+136    	; 0xdd6 <xQueueGenericReceive+0x12c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d4e:	6c 81       	ldd	r22, Y+4	; 0x04
     d50:	7d 81       	ldd	r23, Y+5	; 0x05
     d52:	c6 01       	movw	r24, r12
     d54:	0e 94 91 0a 	call	0x1522	; 0x1522 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     d58:	c8 01       	movw	r24, r16
     d5a:	0e 94 cd 04 	call	0x99a	; 0x99a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     d5e:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
     d62:	88 23       	and	r24, r24
     d64:	11 f0       	breq	.+4      	; 0xd6a <xQueueGenericReceive+0xc0>
     d66:	21 e0       	ldi	r18, 0x01	; 1
     d68:	b9 cf       	rjmp	.-142    	; 0xcdc <xQueueGenericReceive+0x32>
				{
					portYIELD_WITHIN_API();
     d6a:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
     d6e:	21 e0       	ldi	r18, 0x01	; 1
     d70:	b5 cf       	rjmp	.-150    	; 0xcdc <xQueueGenericReceive+0x32>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     d72:	c8 01       	movw	r24, r16
     d74:	0e 94 cd 04 	call	0x99a	; 0x99a <prvUnlockQueue>
			( void ) xTaskResumeAll();
     d78:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     d82:	f8 01       	movw	r30, r16
     d84:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     d86:	0f 90       	pop	r0
     d88:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d8a:	81 11       	cpse	r24, r1
     d8c:	ec cf       	rjmp	.-40     	; 0xd66 <xQueueGenericReceive+0xbc>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     d8e:	0f 90       	pop	r0
     d90:	0f 90       	pop	r0
     d92:	0f 90       	pop	r0
     d94:	0f 90       	pop	r0
     d96:	0f 90       	pop	r0
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	ff 90       	pop	r15
     da2:	ef 90       	pop	r14
     da4:	df 90       	pop	r13
     da6:	cf 90       	pop	r12
     da8:	bf 90       	pop	r11
     daa:	af 90       	pop	r10
     dac:	08 95       	ret
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     dae:	ce 01       	movw	r24, r28
     db0:	01 96       	adiw	r24, 0x01	; 1
     db2:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <vTaskSetTimeOutState>
     db6:	a1 cf       	rjmp	.-190    	; 0xcfa <xQueueGenericReceive+0x50>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
     db8:	15 8e       	std	Z+29, r1	; 0x1d
     dba:	f8 01       	movw	r30, r16
     dbc:	86 8d       	ldd	r24, Z+30	; 0x1e
     dbe:	8f 3f       	cpi	r24, 0xFF	; 255
     dc0:	09 f0       	breq	.+2      	; 0xdc4 <xQueueGenericReceive+0x11a>
     dc2:	ac cf       	rjmp	.-168    	; 0xd1c <xQueueGenericReceive+0x72>
     dc4:	16 8e       	std	Z+30, r1	; 0x1e
     dc6:	aa cf       	rjmp	.-172    	; 0xd1c <xQueueGenericReceive+0x72>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     dc8:	c8 01       	movw	r24, r16
     dca:	0e 94 cd 04 	call	0x99a	; 0x99a <prvUnlockQueue>
				( void ) xTaskResumeAll();
     dce:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
     dd2:	21 e0       	ldi	r18, 0x01	; 1
     dd4:	83 cf       	rjmp	.-250    	; 0xcdc <xQueueGenericReceive+0x32>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						taskENTER_CRITICAL();
     dd6:	0f b6       	in	r0, 0x3f	; 63
     dd8:	f8 94       	cli
     dda:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     ddc:	82 81       	ldd	r24, Z+2	; 0x02
     dde:	93 81       	ldd	r25, Z+3	; 0x03
     de0:	0e 94 33 0b 	call	0x1666	; 0x1666 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     de4:	0f 90       	pop	r0
     de6:	0f be       	out	0x3f, r0	; 63
     de8:	b2 cf       	rjmp	.-156    	; 0xd4e <xQueueGenericReceive+0xa4>
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     dea:	c6 80       	ldd	r12, Z+6	; 0x06
     dec:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     dee:	b5 01       	movw	r22, r10
     df0:	c8 01       	movw	r24, r16
     df2:	0e 94 b5 04 	call	0x96a	; 0x96a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     df6:	e1 10       	cpse	r14, r1
     df8:	13 c0       	rjmp	.+38     	; 0xe20 <xQueueGenericReceive+0x176>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     dfa:	fa 94       	dec	r15
     dfc:	f8 01       	movw	r30, r16
     dfe:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e00:	80 81       	ld	r24, Z
     e02:	91 81       	ldd	r25, Z+1	; 0x01
     e04:	89 2b       	or	r24, r25
     e06:	11 f1       	breq	.+68     	; 0xe4c <xQueueGenericReceive+0x1a2>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e08:	f8 01       	movw	r30, r16
     e0a:	80 85       	ldd	r24, Z+8	; 0x08
     e0c:	81 11       	cpse	r24, r1
     e0e:	17 c0       	rjmp	.+46     	; 0xe3e <xQueueGenericReceive+0x194>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     e10:	0f 90       	pop	r0
     e12:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     e14:	81 e0       	ldi	r24, 0x01	; 1
     e16:	bb cf       	rjmp	.-138    	; 0xd8e <xQueueGenericReceive+0xe4>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e18:	0f 90       	pop	r0
     e1a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e1c:	80 e0       	ldi	r24, 0x00	; 0
     e1e:	b7 cf       	rjmp	.-146    	; 0xd8e <xQueueGenericReceive+0xe4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     e20:	f8 01       	movw	r30, r16
     e22:	d7 82       	std	Z+7, r13	; 0x07
     e24:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e26:	81 89       	ldd	r24, Z+17	; 0x11
     e28:	88 23       	and	r24, r24
     e2a:	91 f3       	breq	.-28     	; 0xe10 <xQueueGenericReceive+0x166>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e2c:	c8 01       	movw	r24, r16
     e2e:	41 96       	adiw	r24, 0x11	; 17
     e30:	0e 94 a1 0a 	call	0x1542	; 0x1542 <xTaskRemoveFromEventList>
     e34:	88 23       	and	r24, r24
     e36:	61 f3       	breq	.-40     	; 0xe10 <xQueueGenericReceive+0x166>

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
						{
							queueYIELD_IF_USING_PREEMPTION();
     e38:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
     e3c:	e9 cf       	rjmp	.-46     	; 0xe10 <xQueueGenericReceive+0x166>
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e3e:	c8 01       	movw	r24, r16
     e40:	08 96       	adiw	r24, 0x08	; 8
     e42:	0e 94 a1 0a 	call	0x1542	; 0x1542 <xTaskRemoveFromEventList>
     e46:	88 23       	and	r24, r24
     e48:	19 f3       	breq	.-58     	; 0xe10 <xQueueGenericReceive+0x166>
     e4a:	f6 cf       	rjmp	.-20     	; 0xe38 <xQueueGenericReceive+0x18e>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     e4c:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <pvTaskIncrementMutexHeldCount>
     e50:	f8 01       	movw	r30, r16
     e52:	93 83       	std	Z+3, r25	; 0x03
     e54:	82 83       	std	Z+2, r24	; 0x02
     e56:	d8 cf       	rjmp	.-80     	; 0xe08 <xQueueGenericReceive+0x15e>

00000e58 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     e58:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <pxReadyTasksLists>
     e5c:	82 30       	cpi	r24, 0x02	; 2
     e5e:	f0 f3       	brcs	.-4      	; 0xe5c <prvIdleTask+0x4>
     e60:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
     e64:	f9 cf       	rjmp	.-14     	; 0xe58 <prvIdleTask>

00000e66 <prvAddCurrentTaskToDelayedList.isra.2>:
     e66:	0f 93       	push	r16
     e68:	1f 93       	push	r17
     e6a:	cf 93       	push	r28
     e6c:	df 93       	push	r29
     e6e:	ec 01       	movw	r28, r24
     e70:	00 91 69 06 	lds	r16, 0x0669	; 0x800669 <xTickCount>
     e74:	10 91 6a 06 	lds	r17, 0x066A	; 0x80066a <xTickCount+0x1>
     e78:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <pxCurrentTCB>
     e7c:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     e80:	02 96       	adiw	r24, 0x02	; 2
     e82:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
     e86:	c0 0f       	add	r28, r16
     e88:	d1 1f       	adc	r29, r17
     e8a:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
     e8e:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     e92:	d3 83       	std	Z+3, r29	; 0x03
     e94:	c2 83       	std	Z+2, r28	; 0x02
     e96:	60 91 af 06 	lds	r22, 0x06AF	; 0x8006af <pxCurrentTCB>
     e9a:	70 91 b0 06 	lds	r23, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     e9e:	c0 17       	cp	r28, r16
     ea0:	d1 07       	cpc	r29, r17
     ea2:	c0 f0       	brcs	.+48     	; 0xed4 <prvAddCurrentTaskToDelayedList.isra.2+0x6e>
     ea4:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <pxDelayedTaskList>
     ea8:	90 91 78 06 	lds	r25, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
     eac:	6e 5f       	subi	r22, 0xFE	; 254
     eae:	7f 4f       	sbci	r23, 0xFF	; 255
     eb0:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <vListInsert>
     eb4:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <xNextTaskUnblockTime>
     eb8:	90 91 62 06 	lds	r25, 0x0662	; 0x800662 <xNextTaskUnblockTime+0x1>
     ebc:	c8 17       	cp	r28, r24
     ebe:	d9 07       	cpc	r29, r25
     ec0:	20 f4       	brcc	.+8      	; 0xeca <prvAddCurrentTaskToDelayedList.isra.2+0x64>
     ec2:	d0 93 62 06 	sts	0x0662, r29	; 0x800662 <xNextTaskUnblockTime+0x1>
     ec6:	c0 93 61 06 	sts	0x0661, r28	; 0x800661 <xNextTaskUnblockTime>
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	1f 91       	pop	r17
     ed0:	0f 91       	pop	r16
     ed2:	08 95       	ret
     ed4:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <pxOverflowDelayedTaskList>
     ed8:	90 91 76 06 	lds	r25, 0x0676	; 0x800676 <pxOverflowDelayedTaskList+0x1>
     edc:	6e 5f       	subi	r22, 0xFE	; 254
     ede:	7f 4f       	sbci	r23, 0xFF	; 255
     ee0:	df 91       	pop	r29
     ee2:	cf 91       	pop	r28
     ee4:	1f 91       	pop	r17
     ee6:	0f 91       	pop	r16
     ee8:	0c 94 6c 01 	jmp	0x2d8	; 0x2d8 <vListInsert>

00000eec <xTaskCreate>:
     eec:	5f 92       	push	r5
     eee:	6f 92       	push	r6
     ef0:	7f 92       	push	r7
     ef2:	8f 92       	push	r8
     ef4:	9f 92       	push	r9
     ef6:	af 92       	push	r10
     ef8:	bf 92       	push	r11
     efa:	cf 92       	push	r12
     efc:	df 92       	push	r13
     efe:	ef 92       	push	r14
     f00:	ff 92       	push	r15
     f02:	0f 93       	push	r16
     f04:	1f 93       	push	r17
     f06:	cf 93       	push	r28
     f08:	df 93       	push	r29
     f0a:	4c 01       	movw	r8, r24
     f0c:	16 2f       	mov	r17, r22
     f0e:	57 2e       	mov	r5, r23
     f10:	6a 01       	movw	r12, r20
     f12:	59 01       	movw	r10, r18
     f14:	ca 01       	movw	r24, r20
     f16:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <pvPortMalloc>
     f1a:	3c 01       	movw	r6, r24
     f1c:	89 2b       	or	r24, r25
     f1e:	09 f4       	brne	.+2      	; 0xf22 <xTaskCreate+0x36>
     f20:	e4 c0       	rjmp	.+456    	; 0x10ea <xTaskCreate+0x1fe>
     f22:	88 e2       	ldi	r24, 0x28	; 40
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <pvPortMalloc>
     f2a:	ec 01       	movw	r28, r24
     f2c:	89 2b       	or	r24, r25
     f2e:	09 f4       	brne	.+2      	; 0xf32 <xTaskCreate+0x46>
     f30:	d9 c0       	rjmp	.+434    	; 0x10e4 <xTaskCreate+0x1f8>
     f32:	78 8e       	std	Y+24, r7	; 0x18
     f34:	6f 8a       	std	Y+23, r6	; 0x17
     f36:	81 e0       	ldi	r24, 0x01	; 1
     f38:	c8 1a       	sub	r12, r24
     f3a:	d1 08       	sbc	r13, r1
     f3c:	c6 0c       	add	r12, r6
     f3e:	d7 1c       	adc	r13, r7
     f40:	be 01       	movw	r22, r28
     f42:	67 5e       	subi	r22, 0xE7	; 231
     f44:	7f 4f       	sbci	r23, 0xFF	; 255
     f46:	e1 2f       	mov	r30, r17
     f48:	f5 2d       	mov	r31, r5
     f4a:	9f 01       	movw	r18, r30
     f4c:	28 5f       	subi	r18, 0xF8	; 248
     f4e:	3f 4f       	sbci	r19, 0xFF	; 255
     f50:	cf 01       	movw	r24, r30
     f52:	41 91       	ld	r20, Z+
     f54:	db 01       	movw	r26, r22
     f56:	4d 93       	st	X+, r20
     f58:	bd 01       	movw	r22, r26
     f5a:	dc 01       	movw	r26, r24
     f5c:	8c 91       	ld	r24, X
     f5e:	88 23       	and	r24, r24
     f60:	19 f0       	breq	.+6      	; 0xf68 <xTaskCreate+0x7c>
     f62:	e2 17       	cp	r30, r18
     f64:	f3 07       	cpc	r31, r19
     f66:	a1 f7       	brne	.-24     	; 0xf50 <xTaskCreate+0x64>
     f68:	18 a2       	std	Y+32, r1	; 0x20
     f6a:	04 30       	cpi	r16, 0x04	; 4
     f6c:	08 f0       	brcs	.+2      	; 0xf70 <xTaskCreate+0x84>
     f6e:	b4 c0       	rjmp	.+360    	; 0x10d8 <xTaskCreate+0x1ec>
     f70:	0e 8b       	std	Y+22, r16	; 0x16
     f72:	09 a3       	std	Y+33, r16	; 0x21
     f74:	1a a2       	std	Y+34, r1	; 0x22
     f76:	3e 01       	movw	r6, r28
     f78:	b2 e0       	ldi	r27, 0x02	; 2
     f7a:	6b 0e       	add	r6, r27
     f7c:	71 1c       	adc	r7, r1
     f7e:	c3 01       	movw	r24, r6
     f80:	0e 94 47 01 	call	0x28e	; 0x28e <vListInitialiseItem>
     f84:	ce 01       	movw	r24, r28
     f86:	0c 96       	adiw	r24, 0x0c	; 12
     f88:	0e 94 47 01 	call	0x28e	; 0x28e <vListInitialiseItem>
     f8c:	d9 87       	std	Y+9, r29	; 0x09
     f8e:	c8 87       	std	Y+8, r28	; 0x08
     f90:	84 e0       	ldi	r24, 0x04	; 4
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	80 1b       	sub	r24, r16
     f96:	91 09       	sbc	r25, r1
     f98:	9d 87       	std	Y+13, r25	; 0x0d
     f9a:	8c 87       	std	Y+12, r24	; 0x0c
     f9c:	db 8b       	std	Y+19, r29	; 0x13
     f9e:	ca 8b       	std	Y+18, r28	; 0x12
     fa0:	1b a2       	std	Y+35, r1	; 0x23
     fa2:	1c a2       	std	Y+36, r1	; 0x24
     fa4:	1d a2       	std	Y+37, r1	; 0x25
     fa6:	1e a2       	std	Y+38, r1	; 0x26
     fa8:	1f a2       	std	Y+39, r1	; 0x27
     faa:	a5 01       	movw	r20, r10
     fac:	b4 01       	movw	r22, r8
     fae:	c6 01       	movw	r24, r12
     fb0:	0e 94 c9 01 	call	0x392	; 0x392 <pxPortInitialiseStack>
     fb4:	99 83       	std	Y+1, r25	; 0x01
     fb6:	88 83       	st	Y, r24
     fb8:	e1 14       	cp	r14, r1
     fba:	f1 04       	cpc	r15, r1
     fbc:	19 f0       	breq	.+6      	; 0xfc4 <xTaskCreate+0xd8>
     fbe:	f7 01       	movw	r30, r14
     fc0:	d1 83       	std	Z+1, r29	; 0x01
     fc2:	c0 83       	st	Z, r28
     fc4:	0f b6       	in	r0, 0x3f	; 63
     fc6:	f8 94       	cli
     fc8:	0f 92       	push	r0
     fca:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <uxCurrentNumberOfTasks>
     fce:	8f 5f       	subi	r24, 0xFF	; 255
     fd0:	80 93 6b 06 	sts	0x066B, r24	; 0x80066b <uxCurrentNumberOfTasks>
     fd4:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <pxCurrentTCB>
     fd8:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     fdc:	89 2b       	or	r24, r25
     fde:	89 f0       	breq	.+34     	; 0x1002 <xTaskCreate+0x116>
     fe0:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xSchedulerRunning>
     fe4:	81 11       	cpse	r24, r1
     fe6:	3d c0       	rjmp	.+122    	; 0x1062 <xTaskCreate+0x176>
     fe8:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
     fec:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
     ff0:	8e 89       	ldd	r24, Y+22	; 0x16
     ff2:	96 89       	ldd	r25, Z+22	; 0x16
     ff4:	89 17       	cp	r24, r25
     ff6:	b0 f1       	brcs	.+108    	; 0x1064 <xTaskCreate+0x178>
     ff8:	d0 93 b0 06 	sts	0x06B0, r29	; 0x8006b0 <pxCurrentTCB+0x1>
     ffc:	c0 93 af 06 	sts	0x06AF, r28	; 0x8006af <pxCurrentTCB>
    1000:	31 c0       	rjmp	.+98     	; 0x1064 <xTaskCreate+0x178>
    1002:	d0 93 b0 06 	sts	0x06B0, r29	; 0x8006b0 <pxCurrentTCB+0x1>
    1006:	c0 93 af 06 	sts	0x06AF, r28	; 0x8006af <pxCurrentTCB>
    100a:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <uxCurrentNumberOfTasks>
    100e:	81 30       	cpi	r24, 0x01	; 1
    1010:	41 f5       	brne	.+80     	; 0x1062 <xTaskCreate+0x176>
    1012:	8b e8       	ldi	r24, 0x8B	; 139
    1014:	96 e0       	ldi	r25, 0x06	; 6
    1016:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
    101a:	84 e9       	ldi	r24, 0x94	; 148
    101c:	96 e0       	ldi	r25, 0x06	; 6
    101e:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
    1022:	8d e9       	ldi	r24, 0x9D	; 157
    1024:	96 e0       	ldi	r25, 0x06	; 6
    1026:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
    102a:	86 ea       	ldi	r24, 0xA6	; 166
    102c:	96 e0       	ldi	r25, 0x06	; 6
    102e:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
    1032:	82 e8       	ldi	r24, 0x82	; 130
    1034:	96 e0       	ldi	r25, 0x06	; 6
    1036:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
    103a:	89 e7       	ldi	r24, 0x79	; 121
    103c:	96 e0       	ldi	r25, 0x06	; 6
    103e:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
    1042:	8c e6       	ldi	r24, 0x6C	; 108
    1044:	96 e0       	ldi	r25, 0x06	; 6
    1046:	0e 94 39 01 	call	0x272	; 0x272 <vListInitialise>
    104a:	82 e8       	ldi	r24, 0x82	; 130
    104c:	96 e0       	ldi	r25, 0x06	; 6
    104e:	90 93 78 06 	sts	0x0678, r25	; 0x800678 <pxDelayedTaskList+0x1>
    1052:	80 93 77 06 	sts	0x0677, r24	; 0x800677 <pxDelayedTaskList>
    1056:	89 e7       	ldi	r24, 0x79	; 121
    1058:	96 e0       	ldi	r25, 0x06	; 6
    105a:	90 93 76 06 	sts	0x0676, r25	; 0x800676 <pxOverflowDelayedTaskList+0x1>
    105e:	80 93 75 06 	sts	0x0675, r24	; 0x800675 <pxOverflowDelayedTaskList>
    1062:	8e 89       	ldd	r24, Y+22	; 0x16
    1064:	90 91 63 06 	lds	r25, 0x0663	; 0x800663 <uxTaskNumber>
    1068:	9f 5f       	subi	r25, 0xFF	; 255
    106a:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <uxTaskNumber>
    106e:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <uxTopReadyPriority>
    1072:	98 17       	cp	r25, r24
    1074:	70 f1       	brcs	.+92     	; 0x10d2 <xTaskCreate+0x1e6>
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	9c 01       	movw	r18, r24
    107a:	22 0f       	add	r18, r18
    107c:	33 1f       	adc	r19, r19
    107e:	22 0f       	add	r18, r18
    1080:	33 1f       	adc	r19, r19
    1082:	22 0f       	add	r18, r18
    1084:	33 1f       	adc	r19, r19
    1086:	82 0f       	add	r24, r18
    1088:	93 1f       	adc	r25, r19
    108a:	b3 01       	movw	r22, r6
    108c:	85 57       	subi	r24, 0x75	; 117
    108e:	99 4f       	sbci	r25, 0xF9	; 249
    1090:	0e 94 4b 01 	call	0x296	; 0x296 <vListInsertEnd>
    1094:	0f 90       	pop	r0
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xSchedulerRunning>
    109c:	88 23       	and	r24, r24
    109e:	41 f0       	breq	.+16     	; 0x10b0 <xTaskCreate+0x1c4>
    10a0:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
    10a4:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    10a8:	96 89       	ldd	r25, Z+22	; 0x16
    10aa:	8e 89       	ldd	r24, Y+22	; 0x16
    10ac:	98 17       	cp	r25, r24
    10ae:	b0 f0       	brcs	.+44     	; 0x10dc <xTaskCreate+0x1f0>
    10b0:	81 e0       	ldi	r24, 0x01	; 1
    10b2:	df 91       	pop	r29
    10b4:	cf 91       	pop	r28
    10b6:	1f 91       	pop	r17
    10b8:	0f 91       	pop	r16
    10ba:	ff 90       	pop	r15
    10bc:	ef 90       	pop	r14
    10be:	df 90       	pop	r13
    10c0:	cf 90       	pop	r12
    10c2:	bf 90       	pop	r11
    10c4:	af 90       	pop	r10
    10c6:	9f 90       	pop	r9
    10c8:	8f 90       	pop	r8
    10ca:	7f 90       	pop	r7
    10cc:	6f 90       	pop	r6
    10ce:	5f 90       	pop	r5
    10d0:	08 95       	ret
    10d2:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <uxTopReadyPriority>
    10d6:	cf cf       	rjmp	.-98     	; 0x1076 <xTaskCreate+0x18a>
    10d8:	03 e0       	ldi	r16, 0x03	; 3
    10da:	4a cf       	rjmp	.-364    	; 0xf70 <xTaskCreate+0x84>
    10dc:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	e7 cf       	rjmp	.-50     	; 0x10b2 <xTaskCreate+0x1c6>
    10e4:	c3 01       	movw	r24, r6
    10e6:	0e 94 28 04 	call	0x850	; 0x850 <vPortFree>
    10ea:	8f ef       	ldi	r24, 0xFF	; 255
    10ec:	e2 cf       	rjmp	.-60     	; 0x10b2 <xTaskCreate+0x1c6>

000010ee <vTaskStartScheduler>:
    10ee:	ef 92       	push	r14
    10f0:	ff 92       	push	r15
    10f2:	0f 93       	push	r16
    10f4:	8f e5       	ldi	r24, 0x5F	; 95
    10f6:	e8 2e       	mov	r14, r24
    10f8:	86 e0       	ldi	r24, 0x06	; 6
    10fa:	f8 2e       	mov	r15, r24
    10fc:	00 e0       	ldi	r16, 0x00	; 0
    10fe:	20 e0       	ldi	r18, 0x00	; 0
    1100:	30 e0       	ldi	r19, 0x00	; 0
    1102:	45 e5       	ldi	r20, 0x55	; 85
    1104:	50 e0       	ldi	r21, 0x00	; 0
    1106:	60 e7       	ldi	r22, 0x70	; 112
    1108:	70 e0       	ldi	r23, 0x00	; 0
    110a:	8c e2       	ldi	r24, 0x2C	; 44
    110c:	97 e0       	ldi	r25, 0x07	; 7
    110e:	0e 94 76 07 	call	0xeec	; 0xeec <xTaskCreate>
    1112:	81 30       	cpi	r24, 0x01	; 1
    1114:	21 f0       	breq	.+8      	; 0x111e <vTaskStartScheduler+0x30>
    1116:	0f 91       	pop	r16
    1118:	ff 90       	pop	r15
    111a:	ef 90       	pop	r14
    111c:	08 95       	ret
    111e:	f8 94       	cli
    1120:	2f ef       	ldi	r18, 0xFF	; 255
    1122:	3f ef       	ldi	r19, 0xFF	; 255
    1124:	30 93 62 06 	sts	0x0662, r19	; 0x800662 <xNextTaskUnblockTime+0x1>
    1128:	20 93 61 06 	sts	0x0661, r18	; 0x800661 <xNextTaskUnblockTime>
    112c:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <xSchedulerRunning>
    1130:	10 92 6a 06 	sts	0x066A, r1	; 0x80066a <xTickCount+0x1>
    1134:	10 92 69 06 	sts	0x0669, r1	; 0x800669 <xTickCount>
    1138:	0f 91       	pop	r16
    113a:	ff 90       	pop	r15
    113c:	ef 90       	pop	r14
    113e:	0c 94 35 02 	jmp	0x46a	; 0x46a <xPortStartScheduler>

00001142 <vTaskSuspendAll>:
    1142:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxSchedulerSuspended>
    1146:	8f 5f       	subi	r24, 0xFF	; 255
    1148:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxSchedulerSuspended>
    114c:	08 95       	ret

0000114e <xTaskGetTickCount>:
    114e:	0f b6       	in	r0, 0x3f	; 63
    1150:	f8 94       	cli
    1152:	0f 92       	push	r0
    1154:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xTickCount>
    1158:	90 91 6a 06 	lds	r25, 0x066A	; 0x80066a <xTickCount+0x1>
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	08 95       	ret

00001162 <xTaskIncrementTick>:
    1162:	df 92       	push	r13
    1164:	ef 92       	push	r14
    1166:	ff 92       	push	r15
    1168:	0f 93       	push	r16
    116a:	1f 93       	push	r17
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxSchedulerSuspended>
    1174:	81 11       	cpse	r24, r1
    1176:	b2 c0       	rjmp	.+356    	; 0x12dc <xTaskIncrementTick+0x17a>
    1178:	e0 90 69 06 	lds	r14, 0x0669	; 0x800669 <xTickCount>
    117c:	f0 90 6a 06 	lds	r15, 0x066A	; 0x80066a <xTickCount+0x1>
    1180:	8f ef       	ldi	r24, 0xFF	; 255
    1182:	e8 1a       	sub	r14, r24
    1184:	f8 0a       	sbc	r15, r24
    1186:	f0 92 6a 06 	sts	0x066A, r15	; 0x80066a <xTickCount+0x1>
    118a:	e0 92 69 06 	sts	0x0669, r14	; 0x800669 <xTickCount>
    118e:	e1 14       	cp	r14, r1
    1190:	f1 04       	cpc	r15, r1
    1192:	11 f5       	brne	.+68     	; 0x11d8 <xTaskIncrementTick+0x76>
    1194:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <pxDelayedTaskList>
    1198:	90 91 78 06 	lds	r25, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    119c:	20 91 75 06 	lds	r18, 0x0675	; 0x800675 <pxOverflowDelayedTaskList>
    11a0:	30 91 76 06 	lds	r19, 0x0676	; 0x800676 <pxOverflowDelayedTaskList+0x1>
    11a4:	30 93 78 06 	sts	0x0678, r19	; 0x800678 <pxDelayedTaskList+0x1>
    11a8:	20 93 77 06 	sts	0x0677, r18	; 0x800677 <pxDelayedTaskList>
    11ac:	90 93 76 06 	sts	0x0676, r25	; 0x800676 <pxOverflowDelayedTaskList+0x1>
    11b0:	80 93 75 06 	sts	0x0675, r24	; 0x800675 <pxOverflowDelayedTaskList>
    11b4:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <xNumOfOverflows>
    11b8:	8f 5f       	subi	r24, 0xFF	; 255
    11ba:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <xNumOfOverflows>
    11be:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
    11c2:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    11c6:	80 81       	ld	r24, Z
    11c8:	81 11       	cpse	r24, r1
    11ca:	8f c0       	rjmp	.+286    	; 0x12ea <xTaskIncrementTick+0x188>
    11cc:	8f ef       	ldi	r24, 0xFF	; 255
    11ce:	9f ef       	ldi	r25, 0xFF	; 255
    11d0:	90 93 62 06 	sts	0x0662, r25	; 0x800662 <xNextTaskUnblockTime+0x1>
    11d4:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xNextTaskUnblockTime>
    11d8:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <xNextTaskUnblockTime>
    11dc:	90 91 62 06 	lds	r25, 0x0662	; 0x800662 <xNextTaskUnblockTime+0x1>
    11e0:	d1 2c       	mov	r13, r1
    11e2:	e8 16       	cp	r14, r24
    11e4:	f9 06       	cpc	r15, r25
    11e6:	08 f4       	brcc	.+2      	; 0x11ea <xTaskIncrementTick+0x88>
    11e8:	53 c0       	rjmp	.+166    	; 0x1290 <xTaskIncrementTick+0x12e>
    11ea:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
    11ee:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    11f2:	80 81       	ld	r24, Z
    11f4:	88 23       	and	r24, r24
    11f6:	09 f4       	brne	.+2      	; 0x11fa <xTaskIncrementTick+0x98>
    11f8:	45 c0       	rjmp	.+138    	; 0x1284 <xTaskIncrementTick+0x122>
    11fa:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
    11fe:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    1202:	05 80       	ldd	r0, Z+5	; 0x05
    1204:	f6 81       	ldd	r31, Z+6	; 0x06
    1206:	e0 2d       	mov	r30, r0
    1208:	c6 81       	ldd	r28, Z+6	; 0x06
    120a:	d7 81       	ldd	r29, Z+7	; 0x07
    120c:	8a 81       	ldd	r24, Y+2	; 0x02
    120e:	9b 81       	ldd	r25, Y+3	; 0x03
    1210:	e8 16       	cp	r14, r24
    1212:	f9 06       	cpc	r15, r25
    1214:	08 f4       	brcc	.+2      	; 0x1218 <xTaskIncrementTick+0xb6>
    1216:	7a c0       	rjmp	.+244    	; 0x130c <xTaskIncrementTick+0x1aa>
    1218:	8e 01       	movw	r16, r28
    121a:	0e 5f       	subi	r16, 0xFE	; 254
    121c:	1f 4f       	sbci	r17, 0xFF	; 255
    121e:	c8 01       	movw	r24, r16
    1220:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    1224:	8c 89       	ldd	r24, Y+20	; 0x14
    1226:	9d 89       	ldd	r25, Y+21	; 0x15
    1228:	89 2b       	or	r24, r25
    122a:	21 f0       	breq	.+8      	; 0x1234 <xTaskIncrementTick+0xd2>
    122c:	ce 01       	movw	r24, r28
    122e:	0c 96       	adiw	r24, 0x0c	; 12
    1230:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    1234:	8e 89       	ldd	r24, Y+22	; 0x16
    1236:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <uxTopReadyPriority>
    123a:	98 17       	cp	r25, r24
    123c:	10 f4       	brcc	.+4      	; 0x1242 <xTaskIncrementTick+0xe0>
    123e:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <uxTopReadyPriority>
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	9c 01       	movw	r18, r24
    1246:	22 0f       	add	r18, r18
    1248:	33 1f       	adc	r19, r19
    124a:	22 0f       	add	r18, r18
    124c:	33 1f       	adc	r19, r19
    124e:	22 0f       	add	r18, r18
    1250:	33 1f       	adc	r19, r19
    1252:	82 0f       	add	r24, r18
    1254:	93 1f       	adc	r25, r19
    1256:	b8 01       	movw	r22, r16
    1258:	85 57       	subi	r24, 0x75	; 117
    125a:	99 4f       	sbci	r25, 0xF9	; 249
    125c:	0e 94 4b 01 	call	0x296	; 0x296 <vListInsertEnd>
    1260:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
    1264:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    1268:	9e 89       	ldd	r25, Y+22	; 0x16
    126a:	86 89       	ldd	r24, Z+22	; 0x16
    126c:	98 17       	cp	r25, r24
    126e:	08 f4       	brcc	.+2      	; 0x1272 <xTaskIncrementTick+0x110>
    1270:	bc cf       	rjmp	.-136    	; 0x11ea <xTaskIncrementTick+0x88>
    1272:	dd 24       	eor	r13, r13
    1274:	d3 94       	inc	r13
    1276:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
    127a:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    127e:	80 81       	ld	r24, Z
    1280:	81 11       	cpse	r24, r1
    1282:	bb cf       	rjmp	.-138    	; 0x11fa <xTaskIncrementTick+0x98>
    1284:	8f ef       	ldi	r24, 0xFF	; 255
    1286:	9f ef       	ldi	r25, 0xFF	; 255
    1288:	90 93 62 06 	sts	0x0662, r25	; 0x800662 <xNextTaskUnblockTime+0x1>
    128c:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xNextTaskUnblockTime>
    1290:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
    1294:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    1298:	86 89       	ldd	r24, Z+22	; 0x16
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	fc 01       	movw	r30, r24
    129e:	ee 0f       	add	r30, r30
    12a0:	ff 1f       	adc	r31, r31
    12a2:	ee 0f       	add	r30, r30
    12a4:	ff 1f       	adc	r31, r31
    12a6:	ee 0f       	add	r30, r30
    12a8:	ff 1f       	adc	r31, r31
    12aa:	8e 0f       	add	r24, r30
    12ac:	9f 1f       	adc	r25, r31
    12ae:	fc 01       	movw	r30, r24
    12b0:	e5 57       	subi	r30, 0x75	; 117
    12b2:	f9 4f       	sbci	r31, 0xF9	; 249
    12b4:	80 81       	ld	r24, Z
    12b6:	82 30       	cpi	r24, 0x02	; 2
    12b8:	10 f0       	brcs	.+4      	; 0x12be <xTaskIncrementTick+0x15c>
    12ba:	dd 24       	eor	r13, r13
    12bc:	d3 94       	inc	r13
    12be:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <xYieldPending>
    12c2:	88 23       	and	r24, r24
    12c4:	11 f0       	breq	.+4      	; 0x12ca <xTaskIncrementTick+0x168>
    12c6:	dd 24       	eor	r13, r13
    12c8:	d3 94       	inc	r13
    12ca:	8d 2d       	mov	r24, r13
    12cc:	df 91       	pop	r29
    12ce:	cf 91       	pop	r28
    12d0:	1f 91       	pop	r17
    12d2:	0f 91       	pop	r16
    12d4:	ff 90       	pop	r15
    12d6:	ef 90       	pop	r14
    12d8:	df 90       	pop	r13
    12da:	08 95       	ret
    12dc:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <uxPendedTicks>
    12e0:	8f 5f       	subi	r24, 0xFF	; 255
    12e2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <uxPendedTicks>
    12e6:	d1 2c       	mov	r13, r1
    12e8:	ea cf       	rjmp	.-44     	; 0x12be <xTaskIncrementTick+0x15c>
    12ea:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
    12ee:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    12f2:	05 80       	ldd	r0, Z+5	; 0x05
    12f4:	f6 81       	ldd	r31, Z+6	; 0x06
    12f6:	e0 2d       	mov	r30, r0
    12f8:	06 80       	ldd	r0, Z+6	; 0x06
    12fa:	f7 81       	ldd	r31, Z+7	; 0x07
    12fc:	e0 2d       	mov	r30, r0
    12fe:	82 81       	ldd	r24, Z+2	; 0x02
    1300:	93 81       	ldd	r25, Z+3	; 0x03
    1302:	90 93 62 06 	sts	0x0662, r25	; 0x800662 <xNextTaskUnblockTime+0x1>
    1306:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xNextTaskUnblockTime>
    130a:	66 cf       	rjmp	.-308    	; 0x11d8 <xTaskIncrementTick+0x76>
    130c:	90 93 62 06 	sts	0x0662, r25	; 0x800662 <xNextTaskUnblockTime+0x1>
    1310:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xNextTaskUnblockTime>
    1314:	bd cf       	rjmp	.-134    	; 0x1290 <xTaskIncrementTick+0x12e>

00001316 <xTaskResumeAll>:
    1316:	ff 92       	push	r15
    1318:	0f 93       	push	r16
    131a:	1f 93       	push	r17
    131c:	cf 93       	push	r28
    131e:	df 93       	push	r29
    1320:	0f b6       	in	r0, 0x3f	; 63
    1322:	f8 94       	cli
    1324:	0f 92       	push	r0
    1326:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxSchedulerSuspended>
    132a:	81 50       	subi	r24, 0x01	; 1
    132c:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxSchedulerSuspended>
    1330:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxSchedulerSuspended>
    1334:	81 11       	cpse	r24, r1
    1336:	62 c0       	rjmp	.+196    	; 0x13fc <xTaskResumeAll+0xe6>
    1338:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <uxCurrentNumberOfTasks>
    133c:	88 23       	and	r24, r24
    133e:	09 f4       	brne	.+2      	; 0x1342 <xTaskResumeAll+0x2c>
    1340:	5d c0       	rjmp	.+186    	; 0x13fc <xTaskResumeAll+0xe6>
    1342:	c0 e0       	ldi	r28, 0x00	; 0
    1344:	d0 e0       	ldi	r29, 0x00	; 0
    1346:	ff 24       	eor	r15, r15
    1348:	f3 94       	inc	r15
    134a:	80 91 6c 06 	lds	r24, 0x066C	; 0x80066c <xPendingReadyList>
    134e:	88 23       	and	r24, r24
    1350:	a1 f1       	breq	.+104    	; 0x13ba <xTaskResumeAll+0xa4>
    1352:	e0 91 71 06 	lds	r30, 0x0671	; 0x800671 <xPendingReadyList+0x5>
    1356:	f0 91 72 06 	lds	r31, 0x0672	; 0x800672 <xPendingReadyList+0x6>
    135a:	c6 81       	ldd	r28, Z+6	; 0x06
    135c:	d7 81       	ldd	r29, Z+7	; 0x07
    135e:	ce 01       	movw	r24, r28
    1360:	0c 96       	adiw	r24, 0x0c	; 12
    1362:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    1366:	8e 01       	movw	r16, r28
    1368:	0e 5f       	subi	r16, 0xFE	; 254
    136a:	1f 4f       	sbci	r17, 0xFF	; 255
    136c:	c8 01       	movw	r24, r16
    136e:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    1372:	8e 89       	ldd	r24, Y+22	; 0x16
    1374:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <uxTopReadyPriority>
    1378:	98 17       	cp	r25, r24
    137a:	10 f4       	brcc	.+4      	; 0x1380 <xTaskResumeAll+0x6a>
    137c:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <uxTopReadyPriority>
    1380:	90 e0       	ldi	r25, 0x00	; 0
    1382:	9c 01       	movw	r18, r24
    1384:	22 0f       	add	r18, r18
    1386:	33 1f       	adc	r19, r19
    1388:	22 0f       	add	r18, r18
    138a:	33 1f       	adc	r19, r19
    138c:	22 0f       	add	r18, r18
    138e:	33 1f       	adc	r19, r19
    1390:	82 0f       	add	r24, r18
    1392:	93 1f       	adc	r25, r19
    1394:	b8 01       	movw	r22, r16
    1396:	85 57       	subi	r24, 0x75	; 117
    1398:	99 4f       	sbci	r25, 0xF9	; 249
    139a:	0e 94 4b 01 	call	0x296	; 0x296 <vListInsertEnd>
    139e:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
    13a2:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    13a6:	9e 89       	ldd	r25, Y+22	; 0x16
    13a8:	86 89       	ldd	r24, Z+22	; 0x16
    13aa:	98 17       	cp	r25, r24
    13ac:	70 f2       	brcs	.-100    	; 0x134a <xTaskResumeAll+0x34>
    13ae:	f0 92 65 06 	sts	0x0665, r15	; 0x800665 <xYieldPending>
    13b2:	80 91 6c 06 	lds	r24, 0x066C	; 0x80066c <xPendingReadyList>
    13b6:	81 11       	cpse	r24, r1
    13b8:	cc cf       	rjmp	.-104    	; 0x1352 <xTaskResumeAll+0x3c>
    13ba:	cd 2b       	or	r28, r29
    13bc:	69 f0       	breq	.+26     	; 0x13d8 <xTaskResumeAll+0xc2>
    13be:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
    13c2:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    13c6:	80 81       	ld	r24, Z
    13c8:	81 11       	cpse	r24, r1
    13ca:	25 c0       	rjmp	.+74     	; 0x1416 <xTaskResumeAll+0x100>
    13cc:	8f ef       	ldi	r24, 0xFF	; 255
    13ce:	9f ef       	ldi	r25, 0xFF	; 255
    13d0:	90 93 62 06 	sts	0x0662, r25	; 0x800662 <xNextTaskUnblockTime+0x1>
    13d4:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xNextTaskUnblockTime>
    13d8:	c0 91 66 06 	lds	r28, 0x0666	; 0x800666 <uxPendedTicks>
    13dc:	cc 23       	and	r28, r28
    13de:	51 f0       	breq	.+20     	; 0x13f4 <xTaskResumeAll+0xde>
    13e0:	d1 e0       	ldi	r29, 0x01	; 1
    13e2:	0e 94 b1 08 	call	0x1162	; 0x1162 <xTaskIncrementTick>
    13e6:	81 11       	cpse	r24, r1
    13e8:	d0 93 65 06 	sts	0x0665, r29	; 0x800665 <xYieldPending>
    13ec:	c1 50       	subi	r28, 0x01	; 1
    13ee:	c9 f7       	brne	.-14     	; 0x13e2 <xTaskResumeAll+0xcc>
    13f0:	10 92 66 06 	sts	0x0666, r1	; 0x800666 <uxPendedTicks>
    13f4:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <xYieldPending>
    13f8:	81 11       	cpse	r24, r1
    13fa:	09 c0       	rjmp	.+18     	; 0x140e <xTaskResumeAll+0xf8>
    13fc:	80 e0       	ldi	r24, 0x00	; 0
    13fe:	0f 90       	pop	r0
    1400:	0f be       	out	0x3f, r0	; 63
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	1f 91       	pop	r17
    1408:	0f 91       	pop	r16
    140a:	ff 90       	pop	r15
    140c:	08 95       	ret
    140e:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	f4 cf       	rjmp	.-24     	; 0x13fe <xTaskResumeAll+0xe8>
    1416:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
    141a:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
    141e:	05 80       	ldd	r0, Z+5	; 0x05
    1420:	f6 81       	ldd	r31, Z+6	; 0x06
    1422:	e0 2d       	mov	r30, r0
    1424:	06 80       	ldd	r0, Z+6	; 0x06
    1426:	f7 81       	ldd	r31, Z+7	; 0x07
    1428:	e0 2d       	mov	r30, r0
    142a:	82 81       	ldd	r24, Z+2	; 0x02
    142c:	93 81       	ldd	r25, Z+3	; 0x03
    142e:	90 93 62 06 	sts	0x0662, r25	; 0x800662 <xNextTaskUnblockTime+0x1>
    1432:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xNextTaskUnblockTime>
    1436:	d0 cf       	rjmp	.-96     	; 0x13d8 <xTaskResumeAll+0xc2>

00001438 <vTaskDelayUntil>:
    1438:	fc 01       	movw	r30, r24
    143a:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxSchedulerSuspended>
    143e:	9f 5f       	subi	r25, 0xFF	; 255
    1440:	90 93 5e 06 	sts	0x065E, r25	; 0x80065e <uxSchedulerSuspended>
    1444:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xTickCount>
    1448:	90 91 6a 06 	lds	r25, 0x066A	; 0x80066a <xTickCount+0x1>
    144c:	20 81       	ld	r18, Z
    144e:	31 81       	ldd	r19, Z+1	; 0x01
    1450:	62 0f       	add	r22, r18
    1452:	73 1f       	adc	r23, r19
    1454:	82 17       	cp	r24, r18
    1456:	93 07       	cpc	r25, r19
    1458:	50 f4       	brcc	.+20     	; 0x146e <vTaskDelayUntil+0x36>
    145a:	62 17       	cp	r22, r18
    145c:	73 07       	cpc	r23, r19
    145e:	50 f0       	brcs	.+20     	; 0x1474 <vTaskDelayUntil+0x3c>
    1460:	71 83       	std	Z+1, r23	; 0x01
    1462:	60 83       	st	Z, r22
    1464:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
    1468:	88 23       	and	r24, r24
    146a:	99 f0       	breq	.+38     	; 0x1492 <vTaskDelayUntil+0x5a>
    146c:	08 95       	ret
    146e:	62 17       	cp	r22, r18
    1470:	73 07       	cpc	r23, r19
    1472:	18 f0       	brcs	.+6      	; 0x147a <vTaskDelayUntil+0x42>
    1474:	86 17       	cp	r24, r22
    1476:	97 07       	cpc	r25, r23
    1478:	98 f7       	brcc	.-26     	; 0x1460 <vTaskDelayUntil+0x28>
    147a:	71 83       	std	Z+1, r23	; 0x01
    147c:	60 83       	st	Z, r22
    147e:	9b 01       	movw	r18, r22
    1480:	28 1b       	sub	r18, r24
    1482:	39 0b       	sbc	r19, r25
    1484:	c9 01       	movw	r24, r18
    1486:	0e 94 33 07 	call	0xe66	; 0xe66 <prvAddCurrentTaskToDelayedList.isra.2>
    148a:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskResumeAll>
    148e:	81 11       	cpse	r24, r1
    1490:	ed cf       	rjmp	.-38     	; 0x146c <vTaskDelayUntil+0x34>
    1492:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortYield>
    1496:	08 95       	ret

00001498 <vTaskSwitchContext>:
    1498:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxSchedulerSuspended>
    149c:	81 11       	cpse	r24, r1
    149e:	35 c0       	rjmp	.+106    	; 0x150a <vTaskSwitchContext+0x72>
    14a0:	10 92 65 06 	sts	0x0665, r1	; 0x800665 <xYieldPending>
    14a4:	20 91 68 06 	lds	r18, 0x0668	; 0x800668 <uxTopReadyPriority>
    14a8:	01 c0       	rjmp	.+2      	; 0x14ac <vTaskSwitchContext+0x14>
    14aa:	21 50       	subi	r18, 0x01	; 1
    14ac:	82 2f       	mov	r24, r18
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	ac 01       	movw	r20, r24
    14b2:	44 0f       	add	r20, r20
    14b4:	55 1f       	adc	r21, r21
    14b6:	44 0f       	add	r20, r20
    14b8:	55 1f       	adc	r21, r21
    14ba:	44 0f       	add	r20, r20
    14bc:	55 1f       	adc	r21, r21
    14be:	fa 01       	movw	r30, r20
    14c0:	e8 0f       	add	r30, r24
    14c2:	f9 1f       	adc	r31, r25
    14c4:	e5 57       	subi	r30, 0x75	; 117
    14c6:	f9 4f       	sbci	r31, 0xF9	; 249
    14c8:	30 81       	ld	r19, Z
    14ca:	33 23       	and	r19, r19
    14cc:	71 f3       	breq	.-36     	; 0x14aa <vTaskSwitchContext+0x12>
    14ce:	84 0f       	add	r24, r20
    14d0:	95 1f       	adc	r25, r21
    14d2:	dc 01       	movw	r26, r24
    14d4:	a5 57       	subi	r26, 0x75	; 117
    14d6:	b9 4f       	sbci	r27, 0xF9	; 249
    14d8:	11 96       	adiw	r26, 0x01	; 1
    14da:	ed 91       	ld	r30, X+
    14dc:	fc 91       	ld	r31, X
    14de:	12 97       	sbiw	r26, 0x02	; 2
    14e0:	02 80       	ldd	r0, Z+2	; 0x02
    14e2:	f3 81       	ldd	r31, Z+3	; 0x03
    14e4:	e0 2d       	mov	r30, r0
    14e6:	12 96       	adiw	r26, 0x02	; 2
    14e8:	fc 93       	st	X, r31
    14ea:	ee 93       	st	-X, r30
    14ec:	11 97       	sbiw	r26, 0x01	; 1
    14ee:	82 57       	subi	r24, 0x72	; 114
    14f0:	99 4f       	sbci	r25, 0xF9	; 249
    14f2:	e8 17       	cp	r30, r24
    14f4:	f9 07       	cpc	r31, r25
    14f6:	69 f0       	breq	.+26     	; 0x1512 <vTaskSwitchContext+0x7a>
    14f8:	86 81       	ldd	r24, Z+6	; 0x06
    14fa:	97 81       	ldd	r25, Z+7	; 0x07
    14fc:	90 93 b0 06 	sts	0x06B0, r25	; 0x8006b0 <pxCurrentTCB+0x1>
    1500:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <pxCurrentTCB>
    1504:	20 93 68 06 	sts	0x0668, r18	; 0x800668 <uxTopReadyPriority>
    1508:	08 95       	ret
    150a:	81 e0       	ldi	r24, 0x01	; 1
    150c:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xYieldPending>
    1510:	08 95       	ret
    1512:	02 80       	ldd	r0, Z+2	; 0x02
    1514:	f3 81       	ldd	r31, Z+3	; 0x03
    1516:	e0 2d       	mov	r30, r0
    1518:	12 96       	adiw	r26, 0x02	; 2
    151a:	fc 93       	st	X, r31
    151c:	ee 93       	st	-X, r30
    151e:	11 97       	sbiw	r26, 0x01	; 1
    1520:	eb cf       	rjmp	.-42     	; 0x14f8 <vTaskSwitchContext+0x60>

00001522 <vTaskPlaceOnEventList>:
    1522:	cf 93       	push	r28
    1524:	df 93       	push	r29
    1526:	eb 01       	movw	r28, r22
    1528:	60 91 af 06 	lds	r22, 0x06AF	; 0x8006af <pxCurrentTCB>
    152c:	70 91 b0 06 	lds	r23, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    1530:	64 5f       	subi	r22, 0xF4	; 244
    1532:	7f 4f       	sbci	r23, 0xFF	; 255
    1534:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <vListInsert>
    1538:	ce 01       	movw	r24, r28
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	0c 94 33 07 	jmp	0xe66	; 0xe66 <prvAddCurrentTaskToDelayedList.isra.2>

00001542 <xTaskRemoveFromEventList>:
    1542:	0f 93       	push	r16
    1544:	1f 93       	push	r17
    1546:	cf 93       	push	r28
    1548:	df 93       	push	r29
    154a:	dc 01       	movw	r26, r24
    154c:	15 96       	adiw	r26, 0x05	; 5
    154e:	ed 91       	ld	r30, X+
    1550:	fc 91       	ld	r31, X
    1552:	16 97       	sbiw	r26, 0x06	; 6
    1554:	c6 81       	ldd	r28, Z+6	; 0x06
    1556:	d7 81       	ldd	r29, Z+7	; 0x07
    1558:	8e 01       	movw	r16, r28
    155a:	04 5f       	subi	r16, 0xF4	; 244
    155c:	1f 4f       	sbci	r17, 0xFF	; 255
    155e:	c8 01       	movw	r24, r16
    1560:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    1564:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxSchedulerSuspended>
    1568:	81 11       	cpse	r24, r1
    156a:	29 c0       	rjmp	.+82     	; 0x15be <xTaskRemoveFromEventList+0x7c>
    156c:	0a 50       	subi	r16, 0x0A	; 10
    156e:	11 09       	sbc	r17, r1
    1570:	c8 01       	movw	r24, r16
    1572:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    1576:	8e 89       	ldd	r24, Y+22	; 0x16
    1578:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <uxTopReadyPriority>
    157c:	98 17       	cp	r25, r24
    157e:	28 f1       	brcs	.+74     	; 0x15ca <xTaskRemoveFromEventList+0x88>
    1580:	90 e0       	ldi	r25, 0x00	; 0
    1582:	9c 01       	movw	r18, r24
    1584:	22 0f       	add	r18, r18
    1586:	33 1f       	adc	r19, r19
    1588:	22 0f       	add	r18, r18
    158a:	33 1f       	adc	r19, r19
    158c:	22 0f       	add	r18, r18
    158e:	33 1f       	adc	r19, r19
    1590:	82 0f       	add	r24, r18
    1592:	93 1f       	adc	r25, r19
    1594:	b8 01       	movw	r22, r16
    1596:	85 57       	subi	r24, 0x75	; 117
    1598:	99 4f       	sbci	r25, 0xF9	; 249
    159a:	0e 94 4b 01 	call	0x296	; 0x296 <vListInsertEnd>
    159e:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
    15a2:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    15a6:	9e 89       	ldd	r25, Y+22	; 0x16
    15a8:	86 89       	ldd	r24, Z+22	; 0x16
    15aa:	89 17       	cp	r24, r25
    15ac:	88 f4       	brcc	.+34     	; 0x15d0 <xTaskRemoveFromEventList+0x8e>
    15ae:	81 e0       	ldi	r24, 0x01	; 1
    15b0:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xYieldPending>
    15b4:	df 91       	pop	r29
    15b6:	cf 91       	pop	r28
    15b8:	1f 91       	pop	r17
    15ba:	0f 91       	pop	r16
    15bc:	08 95       	ret
    15be:	b8 01       	movw	r22, r16
    15c0:	8c e6       	ldi	r24, 0x6C	; 108
    15c2:	96 e0       	ldi	r25, 0x06	; 6
    15c4:	0e 94 4b 01 	call	0x296	; 0x296 <vListInsertEnd>
    15c8:	ea cf       	rjmp	.-44     	; 0x159e <xTaskRemoveFromEventList+0x5c>
    15ca:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <uxTopReadyPriority>
    15ce:	d8 cf       	rjmp	.-80     	; 0x1580 <xTaskRemoveFromEventList+0x3e>
    15d0:	80 e0       	ldi	r24, 0x00	; 0
    15d2:	df 91       	pop	r29
    15d4:	cf 91       	pop	r28
    15d6:	1f 91       	pop	r17
    15d8:	0f 91       	pop	r16
    15da:	08 95       	ret

000015dc <vTaskSetTimeOutState>:
    15dc:	20 91 64 06 	lds	r18, 0x0664	; 0x800664 <xNumOfOverflows>
    15e0:	fc 01       	movw	r30, r24
    15e2:	20 83       	st	Z, r18
    15e4:	20 91 69 06 	lds	r18, 0x0669	; 0x800669 <xTickCount>
    15e8:	30 91 6a 06 	lds	r19, 0x066A	; 0x80066a <xTickCount+0x1>
    15ec:	32 83       	std	Z+2, r19	; 0x02
    15ee:	21 83       	std	Z+1, r18	; 0x01
    15f0:	08 95       	ret

000015f2 <xTaskCheckForTimeOut>:
    15f2:	fc 01       	movw	r30, r24
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	f8 94       	cli
    15f8:	0f 92       	push	r0
    15fa:	20 91 69 06 	lds	r18, 0x0669	; 0x800669 <xTickCount>
    15fe:	30 91 6a 06 	lds	r19, 0x066A	; 0x80066a <xTickCount+0x1>
    1602:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <xNumOfOverflows>
    1606:	90 81       	ld	r25, Z
    1608:	98 17       	cp	r25, r24
    160a:	31 f1       	breq	.+76     	; 0x1658 <xTaskCheckForTimeOut+0x66>
    160c:	81 81       	ldd	r24, Z+1	; 0x01
    160e:	92 81       	ldd	r25, Z+2	; 0x02
    1610:	28 17       	cp	r18, r24
    1612:	39 07       	cpc	r19, r25
    1614:	e8 f4       	brcc	.+58     	; 0x1650 <xTaskCheckForTimeOut+0x5e>
    1616:	db 01       	movw	r26, r22
    1618:	4d 91       	ld	r20, X+
    161a:	5c 91       	ld	r21, X
    161c:	d9 01       	movw	r26, r18
    161e:	a8 1b       	sub	r26, r24
    1620:	b9 0b       	sbc	r27, r25
    1622:	a4 17       	cp	r26, r20
    1624:	b5 07       	cpc	r27, r21
    1626:	a0 f4       	brcc	.+40     	; 0x1650 <xTaskCheckForTimeOut+0x5e>
    1628:	42 1b       	sub	r20, r18
    162a:	53 0b       	sbc	r21, r19
    162c:	84 0f       	add	r24, r20
    162e:	95 1f       	adc	r25, r21
    1630:	db 01       	movw	r26, r22
    1632:	8d 93       	st	X+, r24
    1634:	9c 93       	st	X, r25
    1636:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <xNumOfOverflows>
    163a:	80 83       	st	Z, r24
    163c:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xTickCount>
    1640:	90 91 6a 06 	lds	r25, 0x066A	; 0x80066a <xTickCount+0x1>
    1644:	92 83       	std	Z+2, r25	; 0x02
    1646:	81 83       	std	Z+1, r24	; 0x01
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	0f 90       	pop	r0
    164c:	0f be       	out	0x3f, r0	; 63
    164e:	08 95       	ret
    1650:	81 e0       	ldi	r24, 0x01	; 1
    1652:	0f 90       	pop	r0
    1654:	0f be       	out	0x3f, r0	; 63
    1656:	08 95       	ret
    1658:	81 81       	ldd	r24, Z+1	; 0x01
    165a:	92 81       	ldd	r25, Z+2	; 0x02
    165c:	dc cf       	rjmp	.-72     	; 0x1616 <xTaskCheckForTimeOut+0x24>

0000165e <vTaskMissedYield>:
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xYieldPending>
    1664:	08 95       	ret

00001666 <vTaskPriorityInherit>:
    1666:	0f 93       	push	r16
    1668:	1f 93       	push	r17
    166a:	cf 93       	push	r28
    166c:	df 93       	push	r29
    166e:	fc 01       	movw	r30, r24
    1670:	89 2b       	or	r24, r25
    1672:	89 f1       	breq	.+98     	; 0x16d6 <vTaskPriorityInherit+0x70>
    1674:	26 89       	ldd	r18, Z+22	; 0x16
    1676:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
    167a:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    167e:	56 96       	adiw	r26, 0x16	; 22
    1680:	8c 91       	ld	r24, X
    1682:	28 17       	cp	r18, r24
    1684:	40 f5       	brcc	.+80     	; 0x16d6 <vTaskPriorityInherit+0x70>
    1686:	84 85       	ldd	r24, Z+12	; 0x0c
    1688:	95 85       	ldd	r25, Z+13	; 0x0d
    168a:	97 fd       	sbrc	r25, 7
    168c:	0c c0       	rjmp	.+24     	; 0x16a6 <vTaskPriorityInherit+0x40>
    168e:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
    1692:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    1696:	56 96       	adiw	r26, 0x16	; 22
    1698:	3c 91       	ld	r19, X
    169a:	84 e0       	ldi	r24, 0x04	; 4
    169c:	90 e0       	ldi	r25, 0x00	; 0
    169e:	83 1b       	sub	r24, r19
    16a0:	91 09       	sbc	r25, r1
    16a2:	95 87       	std	Z+13, r25	; 0x0d
    16a4:	84 87       	std	Z+12, r24	; 0x0c
    16a6:	30 e0       	ldi	r19, 0x00	; 0
    16a8:	c9 01       	movw	r24, r18
    16aa:	88 0f       	add	r24, r24
    16ac:	99 1f       	adc	r25, r25
    16ae:	88 0f       	add	r24, r24
    16b0:	99 1f       	adc	r25, r25
    16b2:	88 0f       	add	r24, r24
    16b4:	99 1f       	adc	r25, r25
    16b6:	28 0f       	add	r18, r24
    16b8:	39 1f       	adc	r19, r25
    16ba:	25 57       	subi	r18, 0x75	; 117
    16bc:	39 4f       	sbci	r19, 0xF9	; 249
    16be:	82 85       	ldd	r24, Z+10	; 0x0a
    16c0:	93 85       	ldd	r25, Z+11	; 0x0b
    16c2:	82 17       	cp	r24, r18
    16c4:	93 07       	cpc	r25, r19
    16c6:	61 f0       	breq	.+24     	; 0x16e0 <vTaskPriorityInherit+0x7a>
    16c8:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
    16cc:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    16d0:	56 96       	adiw	r26, 0x16	; 22
    16d2:	8c 91       	ld	r24, X
    16d4:	86 8b       	std	Z+22, r24	; 0x16
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	0f 91       	pop	r16
    16de:	08 95       	ret
    16e0:	8f 01       	movw	r16, r30
    16e2:	ef 01       	movw	r28, r30
    16e4:	22 96       	adiw	r28, 0x02	; 2
    16e6:	ce 01       	movw	r24, r28
    16e8:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    16ec:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
    16f0:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    16f4:	86 89       	ldd	r24, Z+22	; 0x16
    16f6:	f8 01       	movw	r30, r16
    16f8:	86 8b       	std	Z+22, r24	; 0x16
    16fa:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <uxTopReadyPriority>
    16fe:	98 17       	cp	r25, r24
    1700:	10 f4       	brcc	.+4      	; 0x1706 <vTaskPriorityInherit+0xa0>
    1702:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <uxTopReadyPriority>
    1706:	90 e0       	ldi	r25, 0x00	; 0
    1708:	9c 01       	movw	r18, r24
    170a:	22 0f       	add	r18, r18
    170c:	33 1f       	adc	r19, r19
    170e:	22 0f       	add	r18, r18
    1710:	33 1f       	adc	r19, r19
    1712:	22 0f       	add	r18, r18
    1714:	33 1f       	adc	r19, r19
    1716:	82 0f       	add	r24, r18
    1718:	93 1f       	adc	r25, r19
    171a:	be 01       	movw	r22, r28
    171c:	85 57       	subi	r24, 0x75	; 117
    171e:	99 4f       	sbci	r25, 0xF9	; 249
    1720:	df 91       	pop	r29
    1722:	cf 91       	pop	r28
    1724:	1f 91       	pop	r17
    1726:	0f 91       	pop	r16
    1728:	0c 94 4b 01 	jmp	0x296	; 0x296 <vListInsertEnd>

0000172c <xTaskPriorityDisinherit>:
    172c:	0f 93       	push	r16
    172e:	1f 93       	push	r17
    1730:	cf 93       	push	r28
    1732:	df 93       	push	r29
    1734:	fc 01       	movw	r30, r24
    1736:	89 2b       	or	r24, r25
    1738:	49 f0       	breq	.+18     	; 0x174c <xTaskPriorityDisinherit+0x20>
    173a:	82 a1       	ldd	r24, Z+34	; 0x22
    173c:	81 50       	subi	r24, 0x01	; 1
    173e:	82 a3       	std	Z+34, r24	; 0x22
    1740:	26 89       	ldd	r18, Z+22	; 0x16
    1742:	91 a1       	ldd	r25, Z+33	; 0x21
    1744:	29 17       	cp	r18, r25
    1746:	11 f0       	breq	.+4      	; 0x174c <xTaskPriorityDisinherit+0x20>
    1748:	88 23       	and	r24, r24
    174a:	31 f0       	breq	.+12     	; 0x1758 <xTaskPriorityDisinherit+0x2c>
    174c:	80 e0       	ldi	r24, 0x00	; 0
    174e:	df 91       	pop	r29
    1750:	cf 91       	pop	r28
    1752:	1f 91       	pop	r17
    1754:	0f 91       	pop	r16
    1756:	08 95       	ret
    1758:	ef 01       	movw	r28, r30
    175a:	8f 01       	movw	r16, r30
    175c:	0e 5f       	subi	r16, 0xFE	; 254
    175e:	1f 4f       	sbci	r17, 0xFF	; 255
    1760:	c8 01       	movw	r24, r16
    1762:	0e 94 9d 01 	call	0x33a	; 0x33a <uxListRemove>
    1766:	29 a1       	ldd	r18, Y+33	; 0x21
    1768:	2e 8b       	std	Y+22, r18	; 0x16
    176a:	82 2f       	mov	r24, r18
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	44 e0       	ldi	r20, 0x04	; 4
    1770:	50 e0       	ldi	r21, 0x00	; 0
    1772:	48 1b       	sub	r20, r24
    1774:	59 0b       	sbc	r21, r25
    1776:	5d 87       	std	Y+13, r21	; 0x0d
    1778:	4c 87       	std	Y+12, r20	; 0x0c
    177a:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <uxTopReadyPriority>
    177e:	32 17       	cp	r19, r18
    1780:	10 f4       	brcc	.+4      	; 0x1786 <xTaskPriorityDisinherit+0x5a>
    1782:	20 93 68 06 	sts	0x0668, r18	; 0x800668 <uxTopReadyPriority>
    1786:	9c 01       	movw	r18, r24
    1788:	22 0f       	add	r18, r18
    178a:	33 1f       	adc	r19, r19
    178c:	22 0f       	add	r18, r18
    178e:	33 1f       	adc	r19, r19
    1790:	22 0f       	add	r18, r18
    1792:	33 1f       	adc	r19, r19
    1794:	82 0f       	add	r24, r18
    1796:	93 1f       	adc	r25, r19
    1798:	b8 01       	movw	r22, r16
    179a:	85 57       	subi	r24, 0x75	; 117
    179c:	99 4f       	sbci	r25, 0xF9	; 249
    179e:	0e 94 4b 01 	call	0x296	; 0x296 <vListInsertEnd>
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	df 91       	pop	r29
    17a6:	cf 91       	pop	r28
    17a8:	1f 91       	pop	r17
    17aa:	0f 91       	pop	r16
    17ac:	08 95       	ret

000017ae <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    17ae:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <pxCurrentTCB>
    17b2:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    17b6:	89 2b       	or	r24, r25
    17b8:	39 f0       	breq	.+14     	; 0x17c8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    17ba:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
    17be:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
    17c2:	82 a1       	ldd	r24, Z+34	; 0x22
    17c4:	8f 5f       	subi	r24, 0xFF	; 255
    17c6:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    17c8:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <pxCurrentTCB>
    17cc:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
	}
    17d0:	08 95       	ret

000017d2 <memcpy>:
    17d2:	fb 01       	movw	r30, r22
    17d4:	dc 01       	movw	r26, r24
    17d6:	02 c0       	rjmp	.+4      	; 0x17dc <memcpy+0xa>
    17d8:	01 90       	ld	r0, Z+
    17da:	0d 92       	st	X+, r0
    17dc:	41 50       	subi	r20, 0x01	; 1
    17de:	50 40       	sbci	r21, 0x00	; 0
    17e0:	d8 f7       	brcc	.-10     	; 0x17d8 <memcpy+0x6>
    17e2:	08 95       	ret

000017e4 <_exit>:
    17e4:	f8 94       	cli

000017e6 <__stop_program>:
    17e6:	ff cf       	rjmp	.-2      	; 0x17e6 <__stop_program>
